/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/modules/images.js":
/*!*******************************!*\
  !*** ./src/modules/images.js ***!
  \*******************************/
/*! namespace exports */
/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__.r, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\nconst images = [\n  {\n    author: 'Иван Айвазовский',\n    name: 'Девятый вал',\n    year: '1850',\n  },\n  {\n    author: 'Илья Репин',\n    name: 'Бурлаки на Волге',\n    year: '1873',\n  },\n  {\n    author: 'Илья Репин',\n    name: 'Не ждали',\n    year: '1888',\n  },\n  {\n    author: 'Илья Репин',\n    name: 'Вечорници',\n    year: '1881',\n  },\n  {\n    author: 'Илья Репин',\n    name: 'Проводы новобранца',\n    year: '1879',\n  },\n  {\n    author: 'Илья Репин',\n    name: 'Крестный ход',\n    year: '1883',\n  },\n  {\n    author: 'Илья Репин',\n    name: 'Иван Грозный и сын его Иван',\n    year: '1885',\n  },\n  {\n    author: 'Илья Репин',\n    name: 'Садко',\n    year: '1876',\n  },\n  {\n    author: 'Илья Репин',\n    name: 'Приготовление к экзамену',\n    year: '1864',\n  },\n  {\n    author: 'Илья Репин',\n    name: 'Летний пейзаж',\n    year: '1879',\n  },\n  {\n    author: 'Илья Репин',\n    name: 'Запорожцы',\n    year: '1891',\n  },\n  {\n    author: 'Иван Крамской',\n    name: 'Неизвестная',\n    year: '1883',\n  },\n  {\n    author: 'Сандро Боттичелли',\n    name: 'Рождение Венеры',\n    year: '1486',\n  },\n  {\n    author: 'Иван Шишкин',\n    name: 'Утро в сосновом лесу',\n    year: '1889',\n  },\n  {\n    author: 'Рембрандт',\n    name: 'Ночной дозор',\n    year: '1642',\n  },\n  {\n    author: 'Леонардо да Винчи',\n    name: 'Тайная вечеря',\n    year: '1498',\n  },\n  {\n    author: 'Сальвадор Дали',\n    name: 'Постоянство памяти',\n    year: '1931',\n  },\n  {\n    author: 'Поль Гоген',\n    name: 'Откуда мы пришли? Кто мы? Куда мы идём?',\n    year: '1898',\n  },\n  {\n    author: 'Эжен Делакруа',\n    name: 'Свобода, ведущая народ',\n    year: '1830',\n  },\n  {\n    author: 'Михаил Врубель',\n    name: 'Демон сидящий',\n    year: '1890',\n  },\n  {\n    author: 'Эдуар Мане',\n    name: 'Бар в «Фоли-Бержер»',\n    year: '1882',\n  },\n  {\n    author: 'Тициан',\n    name: 'Любовь земная и Любовь небесная',\n    year: '1516',\n  },\n  {\n    author: 'Михаил Нестеров',\n    name: 'Видение отроку Варфоломею',\n    year: '1890',\n  },\n  {\n    author: 'Питер Брейгель',\n    name: 'Притча о слепых',\n    year: '1568',\n  },\n  {\n    author: 'Виктор Васнецов',\n    name: 'Аленушка',\n    year: '1881',\n  },\n  {\n    author: 'Карл Брюллов',\n    name: 'Последний день Помпеи',\n    year: '1833',\n  },\n  {\n    author: 'Пабло Пикассо',\n    name: 'Девочка на шаре',\n    year: '1905',\n  },\n  {\n    author: 'Эдгар Дега',\n    name: 'Голубые танцовщицы',\n    year: '1897',\n  },\n  {\n    author: 'Леонардо да Винчи',\n    name: 'Мона Лиза',\n    year: '1505',\n  },\n  {\n    author: 'Микеланджело',\n    name: 'Сотворение Адама',\n    year: '1511',\n  },\n  {\n    author: 'Ян Вермеер',\n    name: 'Девушка с жемчужной серёжкой',\n    year: '1665',\n  },\n  {\n    author: 'Василий Суриков',\n    name: 'Боярыня Морозова',\n    year: '1887',\n  },\n  {\n    author: 'Виктор Васнецов',\n    name: 'Богатыри',\n    year: '1898',\n  },\n  {\n    author: 'Андрей Рублев',\n    name: 'Троица',\n    year: '1411',\n  },\n  {\n    author: 'Пабло Пикассо',\n    name: 'Герника',\n    year: '1937',\n  },\n  {\n    author: 'Иероним Босх',\n    name: 'Сад земных наслаждений',\n    year: '1510',\n  },\n  {\n    author: 'Эдвард Мунк',\n    name: 'Крик',\n    year: '1893',\n  },\n  {\n    author: 'Марк Шагал',\n    name: 'Прогулка',\n    year: '1918',\n  },\n  {\n    author: 'Иванов Александр',\n    name: 'Явление Христа народу',\n    year: '1857',\n  },\n  {\n    author: 'Федотов Павел',\n    name: 'Сватовство майора',\n    year: '1852',\n  },\n  {\n    author: 'Василий Верещагин',\n    name: 'Апофеоз войны',\n    year: '1817',\n  },\n  {\n    author: 'Джорджоне',\n    name: 'Спящая Венера',\n    year: '1510',\n  },\n  {\n    author: 'Питер Брейгель',\n    name: 'Охотники на снегу',\n    year: '1565',\n  },\n  {\n    author: 'Караваджо',\n    name: 'Лютнист',\n    year: '1596',\n  },\n  {\n    author: 'Рембрандт',\n    name: 'Даная',\n    year: '1647',\n  },\n  {\n    author: 'Джованни Беллини',\n    name: 'Пир богов',\n    year: '1514',\n  },\n  {\n    author: 'Ян ван Эйк',\n    name: 'Портрет четы Арнольфини',\n    year: '1434',\n  },\n  {\n    author: 'Сандро Боттичелли',\n    name: 'Весна',\n    year: '1482',\n  },\n  {\n    author: 'Леонардо да Винчи',\n    name: 'Благовещение',\n    year: '1475',\n  },\n  {\n    author: 'Леонардо да Винчи',\n    name: 'Дама с горностаем',\n    year: '1490',\n  },\n  {\n    author: 'Леонардо да Винчи',\n    name: 'Мадонна Литта',\n    year: '1491',\n  },\n  {\n    author: 'Рафаэль',\n    name: 'Дама с единорогом',\n    year: '1506',\n  },\n  {\n    author: 'Рафаэль',\n    name: 'Мадонна Бельведерская',\n    year: '1506',\n  },\n  {\n    author: 'Рафаэль',\n    name: 'Сикстинская Мадонна',\n    year: '1520',\n  },\n  {\n    author: 'Тициан',\n    name: 'Динарий Кесаря',\n    year: '1516',\n  },\n  {\n    author: 'Тициан',\n    name: 'Кающаяся Марина Магдалина',\n    year: '1565',\n  },\n  {\n    author: 'Тициан',\n    name: 'Вакханалия',\n    year: '1526',\n  },\n  {\n    author: 'Тициан',\n    name: 'Венера Урбинская',\n    year: '1534',\n  },\n  {\n    author: 'Тициан',\n    name: 'Конный портрет Карла V',\n    year: '1548',\n  },\n  {\n    author: 'Альбрехт Дюрер',\n    name: 'Адам и Ева',\n    year: '1507',\n  },\n  {\n    author: 'Альбрехт Дюрер',\n    name: 'Праздник четок',\n    year: '1506',\n  },\n  {\n    author: 'Веронезе',\n    name: 'Марс и Венера',\n    year: '1560',\n  },\n  {\n    author: 'Веронезе',\n    name: 'Пир в доме Левия',\n    year: '1563',\n  },\n  {\n    author: 'Эль Греко',\n    name: 'Апостолы Петр и Павел',\n    year: '1592',\n  },\n  {\n    author: 'Рембрандт',\n    name: 'Автопортрет с Саскией',\n    year: '1635',\n  },\n  {\n    author: 'Рембрандт',\n    name: 'Христос и грешница',\n    year: '1644',\n  },\n  {\n    author: 'Веласкес',\n    name: 'Бахус',\n    year: '1628',\n  },\n  {\n    author: 'Веласкес',\n    name: 'Инфанта Маргарита',\n    year: '1654',\n  },\n  {\n    author: 'Веласкес',\n    name: 'Поклонение волхвов',\n    year: '1619',\n  },\n  {\n    author: 'Веласкес',\n    name: 'Вилла Медичи в Риме. Полдень',\n    year: '1630',\n  },\n  {\n    author: 'Веласкес',\n    name: 'Венера с зеркалом',\n    year: '1651',\n  },\n  {\n    author: 'Веласкес',\n    name: 'Кузница вулкана',\n    year: '1630',\n  },\n  {\n    author: 'Веласкес',\n    name: 'Менины',\n    year: '1656',\n  },\n  {\n    author: 'Веласкес',\n    name: 'Сдача Бреды',\n    year: '1635',\n  },\n  {\n    author: 'Бартоломео Мурильо',\n    name: 'Мадонна с четками',\n    year: '1655',\n  },\n  {\n    author: 'Бартоломео Мурильо',\n    name: 'Явление и дар Богородицы',\n    year: '1655',\n  },\n  {\n    author: 'Бартоломео Мурильо',\n    name: 'Мальчик с собакой',\n    year: '1650',\n  },\n  {\n    author: 'Бартоломео Мурильо',\n    name: 'Непорочное зачатие',\n    year: '1678',\n  },\n  {\n    author: 'Никола Пуссен',\n    name: 'Пейзаж с Полифемом',\n    year: '1649',\n  },\n  {\n    author: 'Ян Вермеер \"Служанка с кувшином молока',\n    name: 'Молочница',\n    year: '1660',\n  },\n  {\n    author: 'Жан Этьен Лиотар',\n    name: 'Шоколадница',\n    year: '1745',\n  },\n  {\n    author: 'Жан Фрагонар',\n    name: 'Качели',\n    year: '1767',\n  },\n  {\n    author: 'Жан Фрагонар',\n    name: 'Поцелуй украдкой',\n    year: '1788',\n  },\n  {\n    author: 'Гейнсборо',\n    name: 'Дама в голубом',\n    year: '1780',\n  },\n  {\n    author: 'Жан Батист Грёз',\n    name: 'Избалованное дитя',\n    year: '1765',\n  },\n  {\n    author: 'Жан Батист Грёз',\n    name: 'Деревенская помолвка',\n    year: '1761',\n  },\n  {\n    author: 'Владимир Боровиковский',\n    name: 'Портрет Лопухиной',\n    year: '1797',\n  },\n  {\n    author: 'Джон Констебл',\n    name: 'Вид на собор в Солсбери из епископского сада',\n    year: '1823',\n  },\n  {\n    author: 'Василий Тропинин',\n    name: 'Кружевница',\n    year: '1823',\n  },\n  {\n    author: 'Алексей Венецианов',\n    name: 'На жатве. Лето',\n    year: '1827',\n  },\n  {\n    author: 'Алексей Венециановн',\n    name: 'Спящий пастушок',\n    year: '1826',\n  },\n  {\n    author: 'Алексей Венецианов',\n    name: 'На пашне. Весна',\n    year: '1820',\n  },\n  {\n    author: 'Карл Брюллов',\n    name: 'Итальянский полдень',\n    year: '1827',\n  },\n  {\n    author: 'Карл Брюллов',\n    name: 'Всадница',\n    year: '1832',\n  },\n  {\n    author: 'Василий Перов',\n    name: 'Приезд гувернантки в купеческий дом',\n    year: '1866',\n  },\n  {\n    author: 'Василий Перов',\n    name: 'Тройка',\n    year: '1866',\n  },\n  {\n    author: 'Василий Перов',\n    name: 'Сельский крестный ход на Пасхе',\n    year: '1861',\n  },\n  {\n    author: 'Василий Перов',\n    name: 'Птицелов',\n    year: '1870',\n  },\n  {\n    author: 'Василий Перов',\n    name: 'Охотники на привале',\n    year: '1871',\n  },\n  {\n    author: 'Алексей Саврасов',\n    name: 'Грачи прилетели',\n    year: '1871',\n  },\n  {\n    author: 'Фёдор Васильев',\n    name: 'Мокрый луг',\n    year: '1872',\n  },\n  {\n    author: 'Константин Маковский',\n    name: 'Дети, бегущие от грозы',\n    year: '1872',\n  },\n  {\n    author: 'Константин Маковский',\n    name: 'Боярский свадебный пир',\n    year: '1883',\n  },\n  {\n    author: 'Константин Маковский',\n    name: 'Гадание',\n    year: '1890',\n  },\n  {\n    author: 'Константин Маковский',\n    name: 'Портрет графини Софьи',\n    year: '1890',\n  },\n  {\n    author: 'Константин Маковский',\n    name: 'Перемещение ковра Мухаммеда из Мекки в Каир',\n    year: '1875',\n  },\n  {\n    author: 'Василий Поленов',\n    name: 'Деревня Окулова гора',\n    year: '1860',\n  },\n  {\n    author: 'Василий Поленов',\n    name: 'Переправа через реку',\n    year: '1872',\n  },\n  {\n    author: 'Василий Поленов',\n    name: 'В парке',\n    year: '1874',\n  },\n  {\n    author: 'Василий Поленов',\n    name: 'Московский дворик',\n    year: '1877',\n  },\n  {\n    author: 'Василий Поленов',\n    name: 'Бабушкин сад',\n    year: '1878',\n  },\n  {\n    author: 'Огюст Ренуар',\n    name: 'Мост в Шату',\n    year: '1875',\n  },\n  {\n    author: 'Огюст Ренуар',\n    name: 'Прогулка в Булонском лесу',\n    year: '1873',\n  },\n  {\n    author: 'Огюст Ренуар',\n    name: 'Портрет Жанны Самари',\n    year: '1877',\n  },\n  {\n    author: 'Огюст Ренуар',\n    name: 'Завтрак гребцов',\n    year: '1881',\n  },\n  {\n    author: 'Огюст Ренуар',\n    name: 'Зонтики',\n    year: '1886',\n  },\n  {\n    author: 'Архип Куинджи',\n    name: 'На острове Валааме',\n    year: '1873',\n  },\n  {\n    author: 'Архип Куинджи',\n    name: 'Украинская ночь',\n    year: '1876',\n  },\n  {\n    author: 'Архип Куинджи',\n    name: 'Берёзовая роща',\n    year: '1879',\n  },\n  {\n    author: 'Архип Куинджи',\n    name: 'Лунная ночь на Днепре',\n    year: '1880',\n  },\n  {\n    author: 'Василий Суриков',\n    name: 'Утро стрелецкой казни',\n    year: '1881',\n  },\n  {\n    author: 'Василий Суриков',\n    name: 'Взятие снежного городка',\n    year: '1891',\n  },\n  {\n    author: 'Василий Суриков',\n    name: 'Покорение Сибири Ермаком Тимофеевичем',\n    year: '1895',\n  },\n  {\n    author: 'Василий Суриков',\n    name: 'Переход Суворова через Альпы',\n    year: '1899',\n  },\n  {\n    author: 'Валентин Серов',\n    name: 'Девочка с персиками',\n    year: '1887',\n  },\n  {\n    author: 'Исаак Левитан',\n    name: 'Над вечным покоем',\n    year: '1894',\n  },\n  {\n    author: 'Исаак Левитан',\n    name: 'Март',\n    year: '1895',\n  },\n  {\n    author: 'Исаак Левитан',\n    name: 'Золотая осень',\n    year: '1895',\n  },\n  {\n    author: 'Иван Шишкин',\n    name: 'Ручей в берёзовом лесу',\n    year: '1883',\n  },\n  {\n    author: 'Иван Шишкин',\n    name: 'Рожь',\n    year: '1878',\n  },\n  {\n    author: 'Иван Шишкин',\n    name: 'Корабельная роща',\n    year: '1898',\n  },\n  {\n    author: 'Александра Маковский',\n    name: 'Надоела',\n    year: '1897',\n  },\n  {\n    author: 'Франсуа Буше',\n    name: 'Четыре сезона - Весна',\n    year: '1755',\n  },\n  {\n    author: 'Виктор Васнецов',\n    name: 'Витязь на распутье',\n    year: '1878',\n  },\n  {\n    author: 'Виктор Васнецов',\n    name: 'Ковер-самолёт',\n    year: '1880',\n  },\n  {\n    author: 'Виктор Васнецов',\n    name: 'Три царевны подземного царства',\n    year: '1884',\n  },\n  {\n    author: 'Виктор Васнецов',\n    name: 'Иван-царевич на Сером Волке',\n    year: '1888',\n  },\n  {\n    author: 'Виктор Васнецов',\n    name: 'Царь Иван Васильевич Грозный',\n    year: '1896',\n  },\n  {\n    author: 'Николай Богданов-Бельский',\n    name: 'Устный счёт',\n    year: '1895',\n  },\n  {\n    author: 'Николай Богданов-Бельский',\n    name: 'У дверей школы',\n    year: '1897',\n  },\n  {\n    author: 'Эдуард Мане',\n    name: 'Женщина с кувшином',\n    year: '1858',\n  },\n  {\n    author: 'Клод Лоррен',\n    name: 'Отплытие святой Урсулы',\n    year: '1614',\n  },\n  {\n    author: 'Карл Лемох',\n    name: 'Варька',\n    year: '1893',\n  },\n  {\n    author: 'Василий тропинин',\n    name: 'Девушка с горшком роз',\n    year: '1850',\n  },\n  {\n    author: 'Гюстав Курбе',\n    name: 'Мастерская художника',\n    year: '1855',\n  },\n  {\n    author: 'Иван Богданов',\n    name: 'За расчётом',\n    year: '1890',\n  },\n  {\n    author: 'Иван Богданов',\n    name: 'Новичок',\n    year: '1893',\n  },\n  {\n    author: 'Рене Магритт',\n    name: 'Сын человеческий',\n    year: '1964',\n  },\n  {\n    author: 'Сальвадор Дали',\n    name: 'Сон, вызванный полётом пчелы вокруг граната, за секунду до пробуждения',\n    year: '1944',\n  },\n  {\n    author: 'Казимир Малевич',\n    name: 'Черный квадрат',\n    year: '1915',\n  },\n];\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (images);\n\n\n//# sourceURL=webpack://gem-puzzle/./src/modules/images.js?");

/***/ }),

/***/ "./src/script.js":
/*!***********************!*\
  !*** ./src/script.js ***!
  \***********************/
/*! namespace exports */
/*! exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_images__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/images */ \"./src/modules/images.js\");\n;\n\nclass View {\n  constructor() {\n    this.string = {\n      en: {\n        resetBtn: 'new game',\n        gemPuzzle: 'gem-puzzle',\n        startBtn: 'start',\n        stopBtn: 'pause',\n        saveBtn: 'save',\n        loadBtn: 'load',\n        bestResBtn: 'results',\n        soundBtn: 'sound ON',\n        soundBtnOFF: 'sound OFF',\n        stepBtn: 'auto',\n        step: 'step: ',\n        winSlug1: 'You win! steps:',\n        winSlug2: 'time:',\n        close: \"close\",\n        load: \"load game\",\n        bestres: \"the best results\",\n      },\n      ru: {\n        resetBtn: 'заново',\n        gemPuzzle: 'пятнашки',\n        stopBtn: 'пауза',\n        startBtn: 'начать',\n        saveBtn: 'сохранить',\n        loadBtn: 'загрузить',\n        bestResBtn: 'результаты',\n        soundBtn: 'звук ВКЛ',\n        soundBtnOFF: 'звук ВЫВКЛ',\n        stepBtn: 'авто',\n        step: 'шаг: ',\n        winSlug1: 'Победа! шагов:',\n        winSlug2: 'время:',\n        close: \"закрыть\",\n        load: \"загрузить игру\",\n        bestres: \"лучшие результаты\",\n      },\n    };\n    this.lang = 'ru';\n\n    this.mainEl = null;\n    this.mainContainer = null;\n    this.innerEl = null;\n    this.el = null;\n\n    this.tempLog = '';\n    this.tempLogBR = \"\\n\";\n\n    this.sattingsBoardContainer = null;\n    this.gameBoardContainer = null;\n\n    this.dashBoardContainer = null;\n    this.timer = null;\n    this.timerVal = null;\n    this.isPaused = true;\n    this.stopStartBtn = null;\n    this.timerID = null;\n    this.step = 0;\n    this.stepCounterObj = null;\n    this.solvingHint = null;\n    this.winHint = null;\n    this.imagesDescribe = null;\n    this.currentImage = 1;\n    this.animatedWindow = null;\n    this.loadWindowInteraction = null;\n    this.bestResultsWindow = null;\n    this.isBestResultsWindowActive = false;\n    this.bestResMax = 10;\n    this.isSavedGamesWindowActive = false;\n\n    this.matrixDimensionX = null;\n    this.matrixDimensionY = null;\n    this.mainElNum = null;\n    this.defaultDimension = 4;\n    this.dem = {\n      mobile: {\n        3: 106, 4: 80, 5: 64, 6: 53, 7: 45, 8: 40,\n      },\n      tablet: {\n        3: 146, 4: 109, 5: 87, 6: 73, 7: 63, 8: 55,\n      },\n      desktop: {\n        3: 146, 4: 109, 5: 87, 6: 73, 7: 63, 8: 55,\n      },\n    };\n    this.isMobile = false;\n    this.initIsMobile();\n    this.setDimentionXY();\n    this.setMainElNum();\n    this.offset = null;\n    this.setOffset();\n    this.matrix = [];\n    this.shuffledMatrix = [];\n    this.stepMatrix = [];\n    this.shuffledMatrixEvenSumm = 0;\n    this.stepBtn = null;\n    this.bestResBtnObj = null;\n\n    this.soundBtn = null;\n    this.soundObj = null;\n    this.isSound = true;\n\n    this.autoStepSpeed = 500;\n    this.isAutoMode = false;\n    this.autoFnID = null;\n    this.elArr = [];\n    this.elArrN = [];\n\n    this.styleSheet = null;\n    this.setStyleSheet();\n\n    this.img = {\n      imagesPath: \"\",\n      imagesAmount: 150,\n      images: {\n      },\n    };\n\n    /* STOREGE BUNDLE */\n    this.storeDataKey = 'storedatafdfa';\n    this.bestResDataKey = 'storeresfdfa';\n  }\n\n  checkShuffledMatrix() {\n    let check = true;\n    this.shuffledMatrix.forEach((el, i) => {\n      if (this.getCurrentElNum(el) !== i + 1) {\n        check = false;\n      }\n    });\n    return check;\n  }\n\n  makeOrderArr() {\n    let a = 0;\n    let l = this.matrixDimensionX;\n    let shift = 0;\n    this.elArr = [];\n    const arrLngth = Object.keys(this.matrix).length;\n    for (let i = 0; i < arrLngth; i++) {\n      if (((i + 1) % this.matrixDimensionX) === 0) {\n        this.elArrN.push([1, i + 1]);\n        l -= 1;\n        a += 1;\n        this.makeVerticalRow(this.matrixDimensionX, a, l);\n\n        i += 1 + shift;\n        shift += 1;\n      } else {\n        this.elArrN.push([1, i + 1]);\n      }\n    }\n  }\n\n  makeVerticalRow(el, a, l) {\n    let mult = a;\n    let dec = l;\n    while (dec) {\n      this.elArrN.push([2, (el * mult) + a]);\n      mult++;\n      dec--;\n    }\n  }\n\n  makeAISteps() {\n    let i = 0;\n    let leftRightTopBottom = 1;\n    let l;\n\n    let elNum = 0;\n    this.makeOrderArr();\n    const elArr = this.elArrN; // [[2, 9], [2, 17], [2, 25], [2, 33], [2, 41], [2, 49], [2, 57]]; // [[2, 9],[2, 17],[2, 25],[2, 33],[2, 41],[2, 49],[2, 57]]\n    // console.log(this.elArrN);\n    // {\n    //   2: [1, 2, 3],\n    //   3: [1, 2, 3, 4, 7, 5, 6, 7, 8],\n    //   4: [1, 2, 3, 4, 5, 9, 13, 6, 7, 8, 10, 14, 11, 12, 15],\n    //   5: [1, 2, 3, 4, 5, 6, 11, 16, 21, 7, 8, 9, 10, 12, 17, 22, 13, 14, 15, 18, 23, 19, 20, 24],\n    //   6: [1, 2, 3, 4, 5, 6, 7, 13, 19, 25, 31, 8, 9, 10, 12, 14, 20, 26, 32, 15, 16, 17, 18, 21, 27, 33, 22, 23, 24, 28, 34, 29, 30, 35],\n    //   7: [1, 2, 3, 4, 5, 6, 7, 13, 19, 25, 31, 8, 9, 10, 12, 14, 20, 26, 32, 15, 16, 17, 18, 21, 27, 33, 22, 23, 24, 28, 34, 29, 30, 35],\n    //   8: [1, 2, 3, 4, 5, 6, 7, 13, 19, 25, 31, 8, 9, 10, 12, 14, 20, 26, 32, 15, 16, 17, 18, 21, 27, 33, 22, 23, 24, 28, 34, 29, 30, 35],\n    // };\n    // const elNumLast = 15;\n    const CNTX = this;\n    let propPosCondition;\n    this.autoFnID = setInterval(() => {\n      if (i === 0) {\n        if (elArr[elNum]) {\n          // eslint-disable-next-line max-len\n          console.log(`--== ЭЛЕМЕНТ ${elArr[elNum][1]}  ${CNTX.tempGetDirection((CNTX.getPropDir(leftRightTopBottom, elArr[elNum][0])))} ==--`);\n          propPosCondition = CNTX.stepsCompute(elArr[elNum][1], leftRightTopBottom, elArr[elNum][0]);\n          l = CNTX.stepMatrix.length;\n        } else {\n          i = 0;\n        }\n      }\n      if (CNTX.stepMatrix.length === 0) {\n        i = l;\n      }\n      if (propPosCondition) {\n        i = l;\n      }\n      if (!CNTX.isAutoMode) {\n        clearInterval(CNTX.autoFnID);\n        CNTX.stepMatrix = [];\n        console.log('end');\n      }\n      if (i === l) {\n        leftRightTopBottom += 1;\n        this.stepMatrix = [];\n        i = 0;\n        if (leftRightTopBottom > 4) {\n          if (elArr[elNum]) {\n            elNum += 1;\n            leftRightTopBottom = 1;\n          } else {\n            clearInterval(CNTX.autoFnID);\n            CNTX.isAutoMode = false;\n            console.log('end');\n          }\n        }\n      } else {\n        i += 1;\n        if (CNTX.stepMatrix.length !== 0) {\n          // console.log(`${CNTX.stepMatrix[i - 1][0]} ${this.tempGetDirection(CNTX.stepMatrix[i - 1][1])}`);\n          CNTX.makeStep(CNTX.stepMatrix[i - 1][1], CNTX.stepMatrix[i - 1][0]);\n        }\n      }\n    }, this.autoStepSpeed);\n  }\n\n  tempGetDirection(n) {\n    switch (n) {\n      case 1:\n        return 'TOP';\n      case 2:\n        return 'RIGHT';\n      case 3:\n        return 'BOTTOM';\n      case 4:\n        return 'LEFT';\n      default:\n    }\n    return false;\n  }\n\n  initIsMobile() {\n    const w = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n    if (w < 480) {\n      this.isMobile = true;\n    }\n  }\n\n  getBackGroundSize() {\n    return this.getOffset() * this.matrixDimensionX;\n  }\n\n  getBackGroundSizeCSS() {\n    const box = this.getBackGroundSize();\n    return `background-size: ${box}px ${box}px;`;\n  }\n\n  setOffset() {\n    this.offset = this.isMobile ? this.dem.mobile[this.matrixDimensionX] : this.dem.desktop[this.matrixDimensionX];\n  }\n\n  getOffset() {\n    return this.offset;\n  }\n\n  isElOnItsTopRow(elNum) {\n    return this.isElOnPropPosY(elNum);\n  }\n\n  isElOnItsLeftCol(elNum) {\n    return this.isElOnPropPosX(elNum);\n  }\n\n  getBoxElNumViaCurrElNum(elNum) {\n    return this.getElNumViaLeftTopPos(this.getPosX(elNum), this.getPosY(elNum));\n  }\n\n  getCurrentElNumN(elNum) {\n    return parseInt(this.getPosX(elNum) / this.getOffset(), 10) + 1 + parseInt(this.getPosY(elNum) / this.getOffset(), 10) * this.matrixDimensionY;\n  }\n\n  setCurrentMatrixN() {\n    Object.keys(this.matrix).forEach((el, i) => {\n      this.shuffledMatrix[this.getCurrentElNumN(i + 1) - 1] = (i + 1);\n    });\n  }\n\n  getDestElNumByDirection(dir) {\n    switch (dir) {\n      case 'top':\n      case 1:\n        return this.matrixDimensionX * (-1);\n      case 'right':\n      case 2:\n        return 1;\n      case 'bottom':\n      case 3:\n        return this.matrixDimensionX;\n      case 'left':\n      case 4:\n        return -1;\n      default:\n        return -1;\n    }\n  }\n\n  setShffldOnElNumAndGooo(elNum, dir = 'left') {\n    const destElNum = parseInt(this.getDestElNumByDirection(dir), 10);\n    if (elNum !== this.mainElNum && !this.isDrgbl(elNum, dir)) {\n      console.log(`EXCEPTION EL NOT DRGBLE ${dir}`);\n      return;\n    }\n    if (elNum === this.mainElNum && !this.isMelDrgbl(dir)) {\n      console.log(`EXCEPTION MEL CANT MOVE TO TE ${dir}`);\n      return;\n    }\n    let exception = false;\n    let counter = 0;\n    this.shuffledMatrix.forEach((el, i) => {\n      if (el === elNum && counter === 0) {\n        if (this.shuffledMatrix[parseInt(i + destElNum, 10)]) {\n          this.shuffledMatrix[i] = this.shuffledMatrix[i + destElNum];\n          this.shuffledMatrix[i + destElNum] = el;\n          counter++;\n        } else {\n          console.log(`EXCEPTION shuffledMatrix[${i + destElNum}] NOT FOUND: I: ${i} DEST NUM: ${destElNum}`);\n          exception = true;\n        }\n      } else {\n        this.shuffledMatrix[i] = el;\n      }\n    });\n    if (exception) {\n      return;\n    }\n    this.shuffle('notShuffle');\n  }\n\n  getCountOfStepsToPropYPos(elNum) {\n    // console.log(`Y OFFSET  ${(this.matrix[elNum - 1].y / this.getOffset()) - this.getYInitElementPosInsidMatrix(elNum)}`);\n    return (this.matrix[elNum - 1].y / this.getOffset()) - this.getYInitElementPosInsidMatrix(elNum);\n  }\n\n  toBottom(elNum) {\n    // [1, 9, 17, 25, 33, 41, 49, 57]\n    this.setMElUnder(elNum);\n    if (this.stepMatrix.length === 0) {\n      return;\n    }\n    let countOfStepsToPropYPos = ((this.getCountOfStepsToPropYPos(elNum)) * (-1)) - 1;\n    // console.log(`STEPS to PROP Pos Y: ${countOfStepsToPropYPos}`);\n    this.addStep(elNum, 3);\n    while (countOfStepsToPropYPos > 0) {\n      if (this.isElLastOnRow(elNum)) {\n        // console.log('woohooo!');\n        this.goMountOfSteps('left', 1);\n        this.goMountOfSteps('bottom', 2);\n        this.goMountOfSteps('right', 1);\n      } else {\n        this.goMountOfSteps('right', 1);\n        this.goMountOfSteps('bottom', 2);\n        this.goMountOfSteps('left', 1);\n      }\n      this.addStep(elNum, 3);\n      countOfStepsToPropYPos--;\n    }\n  }\n\n  setMElUnder(elNum) {\n    // console.log(`-= SET MEl UNDER ${elNum} WICH ONE ON POS ${this.getCurrentElNum(elNum)}=-`);\n    if (this.isElOnPropPosY(elNum)) {\n      // console.log('EL ON PROP POS Y');\n      return;\n    }\n    /* 1-я и 2-я четверти */\n    if (this.isMElBefore(elNum)) {\n      if (this.isMElOnTheSameRow(elNum) && (this.stepsToRight(elNum) >= 0)) {\n        // console.log(`/* гэл в одной строке справа*/`);\n        this.goMountOfSteps('right', this.getMountOfSteps(elNum, 'right') - 1);\n        this.goMountOfSteps('bottom', 1);\n        this.goMountOfSteps('right', 1);\n        return;\n      }\n      if (this.isMElOnTheSameRow(elNum) && (this.stepsToLeftt(elNum) >= 0)) {\n        // console.log(`/* гэл в одной строке справа*/`);\n        this.goMountOfSteps('left', this.getMountOfSteps(elNum, 'right') - 1);\n        this.goMountOfSteps('bottom', 1);\n        this.goMountOfSteps('left', 1);\n        return;\n      }\n      // console.log('1st 2nd part COMMON (set MEl Under)');\n      if (this.isElLastOnRow(elNum) && this.isMElOnTheSameCol(elNum)) {\n        // console.log('last one in the row and the same coll position');\n        this.goMountOfSteps('bottom', this.getMountOfSteps(elNum, 'bottom') - 1);\n        this.goMountOfSteps('left', 1);\n        this.goMountOfSteps('bottom', 1);\n        this.goMountOfSteps('right', 1);\n        return;\n      }\n      if (this.isMElOnTheSameCol(elNum)) {\n        // console.log('in the same coll position');\n        this.goMountOfSteps('bottom', this.getMountOfSteps(elNum, 'bottom') - 1);\n        this.goMountOfSteps('right', 1);\n        this.goMountOfSteps('bottom', 1);\n        this.goMountOfSteps('left', 1);\n        return;\n      }\n      if ((this.stepsToBottom(elNum) > 0) && (this.stepsToRight(elNum) >= 0)) {\n        // console.log(`/* вниз и вправо есть шаги */`);\n        this.goMountOfSteps('bottom', this.getMountOfSteps(elNum, 'bottom'));\n        this.goMountOfSteps('right', this.getMountOfSteps(elNum, 'right'));\n      }\n      if ((this.stepsToBottom(elNum) > 0) && (this.stepsToLeft(elNum) >= 0)) {\n        // console.log(`/* вниз и влево есть шаги */`);\n        this.goMountOfSteps('bottom', this.getMountOfSteps(elNum, 'bottom'));\n        this.goMountOfSteps('left', this.getMountOfSteps(elNum, 'left'));\n      }\n    } else {\n      /* 3-я и 4-я четверти */\n      if ((this.isMElOnTheSameRow(elNum)) && (this.stepsToLeft(elNum) >= 0)) {\n        // console.log(`/* влево есть шаги *//* мэл в одной строке */`);\n        this.goMountOfSteps('left', this.getMountOfSteps(elNum, 'left') - 1);\n        this.goMountOfSteps('bottom', 1);\n        this.goMountOfSteps('left', 1);\n        return;\n      }\n      if (this.isMElOnTheSameCol(elNum)) { /* гэл в одной колонке */\n        // console.log(`/* гэл в одной колонке */`);\n        this.goMountOfSteps('top', this.getMountOfSteps(elNum, 'top') - 1);\n        return;\n      }\n      /* COMMON ||| - |V */\n      if ((this.stepsTotop(elNum) >= 0) && (this.stepsToRight(elNum) >= 0)) { /* (вверх) */\n        this.goMountOfSteps('right', this.getMountOfSteps(elNum, 'right'));\n        this.goMountOfSteps('top', this.getMountOfSteps(elNum, 'top') - 1);\n      }\n      if ((this.stepsTotop(elNum) >= 0) && (this.stepsToLeft(elNum) >= 0)) {\n        this.goMountOfSteps('left', this.getMountOfSteps(elNum, 'left'));\n        this.goMountOfSteps('top', this.getMountOfSteps(elNum, 'top') - 1);\n      }\n    }\n  }\n\n  toTop(elNum, mode) {\n    this.setMElAbove(elNum, mode);\n    if (this.stepMatrix.length === 0) {\n      return;\n    }\n    let countOfStepsToPropYPos = this.getCountOfStepsToPropYPos(elNum) - 1;\n    this.addStep(elNum, 1);\n    while (countOfStepsToPropYPos > 0) {\n      if (this.isElLastOnRow(elNum)) {\n        // console.log('laaaaast el!');\n        this.goMountOfSteps('left', 1);\n        this.goMountOfSteps('top', 2);\n        this.goMountOfSteps('right', 1);\n      } else {\n        this.goMountOfSteps('right', 1);\n        this.goMountOfSteps('top', 2);\n        this.goMountOfSteps('left', 1);\n      }\n      this.addStep(elNum, 1);\n      countOfStepsToPropYPos--;\n    }\n    /* установка предпоследнего элемента на последнее место */\n    if (this.isItPreLastElInRow(elNum)) {\n      // console.log(`posiiiiition isItPreLastElInRow`);\n      this.goMountOfSteps('right', 1);\n      this.goMountOfSteps('top', 1);\n      this.addStep(elNum, 2);\n    }\n    // if (!this.isElOnPropPos(elNum + 1)) {}\n  }\n\n  isElAfterItsPropCol(elNum) {\n    return this.matrix[elNum - 1].y < this.getYPXPosition(elNum);\n  }\n\n  setMElAbove(elNum, mode) {\n    // console.log(`-= SET MEl ABOVE ${elNum} WICH ONE ON POS ${this.getCurrentElNum(elNum)}=-`);\n    if (this.isElOnPropPosY(elNum)) {\n      // console.log('EL ON PROP POS Y');\n      return;\n    }\n    if (this.isElAfterItsPropCol(elNum)) { // ;this.isElBeforeItsPropRow(elNum)\n      // console.log(`${elNum} El Before Its Prop Row`);\n      return;\n    }\n    /* 1-я и 2-я четверти */\n    if (this.isMElBefore(elNum)) {\n      if (this.isCaseRangedRowAbove(elNum) && mode === 2) {\n        return;\n      }\n      if (this.isCaseRangedRowAbove(elNum)) {\n        /* если элемент стоит под уже установленной строкой, то обходить только снизу, чтобы не испортить позицию предыдущих элов */\n        /* в данном случает это может быть только таже строка */\n        if (this.stepsToRight(elNum) >= 0) { /* (вправо) */\n          // console.log('special case (set MEl ABOVE)');\n          if (this.isElLastOnRow(elNum)) {\n            /* элементы выстраиваем в строку и не действует спец обход снизу */\n            this.goMountOfSteps('right', this.getMountOfSteps(elNum, 'right') - 1);\n            this.goMountOfSteps('top', 1);\n            this.goMountOfSteps('right', 1);\n            return;\n          }\n          this.goMountOfSteps('right', this.getMountOfSteps(elNum, 'right') - 1);\n          this.goMountOfSteps('bottom', 1);\n          this.goMountOfSteps('right', 2);\n          this.goMountOfSteps('top', 2);\n          this.goMountOfSteps('left', 1);\n        }\n        return;\n      }\n      if ((this.isMElOnTheSameRow(elNum)) && (this.stepsToRight(elNum) >= 0)) {\n        // console.log('/* гэл в одной строке *//* вправо есть шаги */');\n        this.goMountOfSteps('right', this.getMountOfSteps(elNum, 'right') - 1);\n        this.goMountOfSteps('top', 1);\n        this.goMountOfSteps('right', 1);\n        return;\n      }\n      // console.log('1st 2nd part (set MEl ABOVE)');\n      if (this.stepsToBottom(elNum) > 0) { /* вниз есть шаги */\n        this.goMountOfSteps('bottom', this.getMountOfSteps(elNum, 'bottom') - 1);\n      }\n      if (this.stepsToRight(elNum) >= 0) { /* вправо есть шаги */\n        this.goMountOfSteps('right', this.getMountOfSteps(elNum, 'right'));\n      }\n      if (this.stepsToLeft(elNum) >= 0) { /* влево есть шаги */\n        this.goMountOfSteps('left', this.getMountOfSteps(elNum, 'left'));\n      }\n    } else {\n      /* 3-я и 4-я четверти */\n      if (this.isMElOnTheSameRow(elNum)) { /* мэл в одной строке */\n        if (this.stepsToLeft(elNum) >= 0) { /* (обход вправо) */\n          this.goMountOfSteps('left', this.getMountOfSteps(elNum, 'left') - 1);\n          this.goMountOfSteps('top', 1);\n          this.goMountOfSteps('left', 1);\n        }\n        return;\n      }\n      if (this.isMElOnTheSameCol(elNum)) { /* гэл в одной колонке */\n        if (this.isMElCanMoveToTheRight()) { /* (обход вправо) */\n          this.goMountOfSteps('right', 1);\n          this.goMountOfSteps('top', this.getMountOfSteps(elNum, 'top') + 1);\n          this.goMountOfSteps('left', 1);\n        } else {\n          this.goMountOfSteps('left', 1);\n          this.goMountOfSteps('top', this.getMountOfSteps(elNum, 'top') + 1);\n          this.goMountOfSteps('right', 1);\n        }\n        return;\n      }\n      if (this.isCaseRangedRowAbove(elNum)) {\n        if (this.stepsTotop(elNum) >= 0) { /* (вверх) */\n          this.goMountOfSteps('top', this.getMountOfSteps(elNum, 'top') - 1);\n        }\n        if (this.stepsToRight(elNum) >= 0) { /* (вправо) */\n          this.goMountOfSteps('right', this.getMountOfSteps(elNum, 'right'));\n        }\n        if (this.stepsToLeft(elNum) >= 0) { /* (влево) */\n          this.goMountOfSteps('left', this.getMountOfSteps(elNum, 'left'));\n        }\n        this.goMountOfSteps('right', 1);\n        this.goMountOfSteps('top', 2);\n        this.goMountOfSteps('left', 1);\n        return;\n      }\n      if (this.stepsTotop(elNum) >= 0) { /* (вверх) */\n        this.goMountOfSteps('top', this.getMountOfSteps(elNum, 'top') - 1);\n      }\n      if (this.stepsToRight(elNum) >= 0) { /* (вправо) */\n        this.goMountOfSteps('right', this.getMountOfSteps(elNum, 'right'));\n      }\n      if (this.stepsToLeft(elNum) >= 0) { /* (влево) */\n        this.goMountOfSteps('left', this.getMountOfSteps(elNum, 'left'));\n      }\n      this.goMountOfSteps('left', 1);\n      this.goMountOfSteps('top', 2);\n      this.goMountOfSteps('right', 1);\n    }\n  }\n\n  getCountOfStepsToPropXPos(elNum) {\n    return (this.matrix[elNum - 1].x / this.getOffset()) - this.getXInitElementPosInsideMatrix(elNum);\n  }\n\n  toLeft(elNum, mode) {\n    // console.log('set MEl Before');\n    this.setMElBefore(elNum);\n\n    if (this.stepMatrix.length === 0) {\n      return;\n    }\n\n    let countOfStepsToPropXPos = this.getCountOfStepsToPropXPos(elNum) - 1;\n    // console.log(`(${this.matrix[elNum - 1].x} / ${this.getOffset()}) - ${this.getXInitElementPosInsideMatrix(elNum)} = ${countOfStepsToPropXPos}`);\n    this.addStep(elNum, 4);\n    while (countOfStepsToPropXPos > 0) {\n      // console.log(`countOfStepsToPropXPos: ----> ${countOfStepsToPropXPos}`);\n      // console.log(`countOfStepsToPropXPos: 999 ${(countOfStepsToPropXPos > 0)}`);\n      if (this.isThereAbilityToGoByBottom(elNum)) {\n        this.goMountOfSteps('bottom', 1);\n        this.goMountOfSteps('left', 2);\n        this.goMountOfSteps('top', 1);\n      } else {\n        this.goMountOfSteps('top', 1);\n        this.goMountOfSteps('left', 2);\n        this.goMountOfSteps('bottom', 1);\n      }\n      this.addStep(elNum, 4);\n      countOfStepsToPropXPos--;\n    }\n    /* установка предпоследнего элемента на последнее место */\n    if ((mode === 2) && (this.isItPreLastElInCol(elNum))) {\n      // console.log(`----- INSTALL TO VERY BOTTOM POS -------`);\n      this.goMountOfSteps('bottom', 1);\n      this.goMountOfSteps('left', 1);\n      this.addStep(elNum, 3);\n    }\n  }\n\n  isItPreLastElInCol(elNum) {\n    return this.getYInitElementPosInsidMatrix(elNum) + 1 === this.matrixDimensionY - 1;\n  }\n\n  isElBeforeItsPropRow(elNum) {\n    return this.matrix[elNum - 1].x < this.getXPXPosition(elNum);\n  }\n\n  setMElBefore(elNum) {\n    // console.log(`-= SET MEl BEFORE ${elNum} WICH ONE ON POS ${this.getCurrentElNum(elNum)}=-`);\n    if (this.isElOnPropPosX(elNum)) {\n      // console.log(`isElOnPropPosX ${this.isElOnPropPosX(elNum)}`);\n      return false;\n    }\n    if (this.isElBeforeItsPropRow(elNum)) {\n      // console.log(`${elNum} El Before Its Prop Row`);\n      return false;\n    }\n    let returnFlag = false;\n    /* 1-я и 2-я четверти */\n    if (this.isMElBefore(elNum)) { /* гэл перед */\n      if (this.isMElOnTheSameRow(elNum) && (this.stepsToRight(elNum) >= 0)) { /* гэл в одной строке */\n        this.goMountOfSteps('right', this.getMountOfSteps(elNum, 'right') - 1); /* вправо есть шаги */\n        return true;\n      }\n      if (this.isMElOnTheSameCol(elNum) && (this.stepsToBottom(elNum) >= 0)) { /* гэл в одной колонке */\n        /* виниз есть шаги    сдесь поправка если более раза необходимо вниз то вначале раз вниз поптом влево... */\n        this.goMountOfSteps('bottom', this.getMountOfSteps(elNum, 'bottom') - 1);\n        this.goMountOfSteps('left', 1);\n        this.goMountOfSteps('bottom', 1);\n        return true;\n      }\n      /* 1-я и 2-я четверти ОБЩЕЕ */\n      if (this.stepsToBottom(elNum) >= 0) { /* виниз есть шаги  */\n        this.goMountOfSteps('bottom', this.getMountOfSteps(elNum, 'bottom') - 1);\n        if (this.stepsToRight(elNum) >= 0) { /* вправо есть шаги */\n          this.goMountOfSteps('right', this.getMountOfSteps(elNum, 'right') - 1);\n        }\n        if (this.stepsToLeft(elNum) >= 0) { /* (влево) */\n          this.goMountOfSteps('left', this.getMountOfSteps(elNum, 'left') + 1);\n        }\n        this.goMountOfSteps('bottom', 1);\n        returnFlag = true;\n      } else {\n        if (this.stepsToRight(elNum) >= 0) { /* вправо есть шаги */\n          this.goMountOfSteps('right', this.getMountOfSteps(elNum, 'right') - 1);\n          returnFlag = true;\n        }\n        if (this.stepsToLeft(elNum) >= 0) { /* (влево) */\n          this.goMountOfSteps('left', this.getMountOfSteps(elNum, 'left') + 1);\n          returnFlag = true;\n        }\n        /* !важно опускать в конце! */\n        if (this.stepsToBottom(elNum) >= 0) { /* (вниз) */\n          this.goMountOfSteps('bottom', this.getMountOfSteps(elNum, 'bottom'));\n          returnFlag = true;\n        }\n      }\n    } else {\n      /* 3-я и 4-я четверти */\n      if (this.isMElOnTheSameRow(elNum)) { /* гэл на одной строке */\n        if (this.isMElCanMoveToTheBottom()) {\n          this.goMountOfSteps('bottom', 1);\n          this.goMountOfSteps('left', this.getMountOfSteps(elNum, 'left') + 1);\n          this.goMountOfSteps('top', 1);\n          return true;\n        }\n        this.goMountOfSteps('top', 1);\n        this.goMountOfSteps('left', this.getMountOfSteps(elNum, 'left') + 1);\n        this.goMountOfSteps('bottom', 1);\n        return true;\n      }\n      if (this.isMElOnTheSameCol(elNum)) { /* гэл в одной колонке */\n        this.goMountOfSteps('left', 1);\n        this.goMountOfSteps('top', this.getMountOfSteps(elNum, 'top'));\n        return true;\n      }\n      /* !важна последовательность */\n      if (this.stepsToRight(elNum) >= 0) { /* (вправо) */\n        this.goMountOfSteps('right', this.getMountOfSteps(elNum, 'right') - 1);\n        returnFlag = true;\n      }\n      if (this.stepsToLeft(elNum) >= 0) { /* (влево) */\n        this.goMountOfSteps('left', this.getMountOfSteps(elNum, 'left') + 1);\n        returnFlag = true;\n      }\n      if (this.stepsTotop(elNum) >= 0) { /* (вверх) */\n        this.goMountOfSteps('top', this.getMountOfSteps(elNum, 'top'));\n        returnFlag = true;\n      }\n    }\n    return returnFlag;\n  }\n\n  isElLastOnRow(elNum) {\n    return this.getXInitElementPosInsideMatrix(elNum) + 1 === this.matrixDimensionX;\n  }\n\n  isItPreLastElInRow(elNum) {\n    return this.getXInitElementPosInsideMatrix(elNum) + 1 === this.matrixDimensionX - 1;\n  }\n\n  toRight(elNum) {\n    // console.log('set MEl After');\n    if (!this.setMElAfter(elNum)) {\n      return;\n    }\n\n    let countOfStepsToPropXPos = this.getCountOfStepsToPropXPos(elNum) * (-1) - 1;\n    this.addStep(elNum, 2);\n    while (countOfStepsToPropXPos > 0) {\n      if (this.isThereAbilityToGoByBottom(elNum)) {\n        // console.log(`isThereAbilityToGoByBottom: ${this.isThereAbilityToGoByBottom(elNum)}`);\n        this.goMountOfSteps('bottom', 1);\n        this.goMountOfSteps('right', 2);\n        this.goMountOfSteps('top', 1);\n      } else {\n        // console.log(`isThereAbilityToGoByBottom: ${this.isThereAbilityToGoByBottom(elNum)}`);\n        this.goMountOfSteps('top', 1);\n        this.goMountOfSteps('right', 2);\n        this.goMountOfSteps('bottom', 1);\n      }\n      this.addStep(elNum, 2);\n      countOfStepsToPropXPos--;\n    }\n  }\n\n  /* если элемент стоит под уже установленной строкой, то обходить только снизу, чтобы не испортить позицию предыдущих элов */\n  isCaseRangedRowAbove(elNum) {\n    return (this.matrix[elNum - 1].x <= this.getXPXPosition(elNum)) && (this.matrix[elNum - 1].y - this.getOffset() === this.getYPXPosition(elNum));\n  }\n\n  setMElAfter(elNum) {\n    console.log(`-= SET MEl AFTER ${elNum} WICH ONE ON POS ${this.getCurrentElNum(elNum)}=-`);\n    if (this.isElOnPropPosX(elNum)) {\n      return false; /* !!!ОШИБКА надо все-равно ставить эл над!!! */\n    }\n    if (!this.isElBeforeItsPropRow(elNum)) { /* isItPsblToSetMElAfter(elNum) this.matrix[elNum - 1].x > this.getXPXPosition(elNum) */\n      console.log(`isElNOTBeforeItsPropRow ${!this.isElBeforeItsPropRow(elNum)} - EXIT FROM setMElAfter`);\n      return false;\n    }\n    let returnFlag = false;\n    /* 1-я и 2-я четверти */\n    if (this.isMElBefore(elNum)) { /* гэл перед эл в матрице */\n      if (this.isCaseRangedRowAbove(elNum)) {\n        console.log('case when ranged row is above');\n        if (this.stepsToRight(elNum) >= 0) {\n          this.goMountOfSteps('right', this.getMountOfSteps(elNum, 'right') - 1);\n          this.goMountOfSteps('bottom', 1);\n          this.goMountOfSteps('right', 2);\n          this.goMountOfSteps('top', 2);\n          return true;\n        }\n        /* редко - случай, когда мэл находится рядом с уже собранным рядом */\n        if (this.stepsToLeft(elNum) >= 0) {\n          this.goMountOfSteps('bottom', 1);\n          this.goMountOfSteps('left', this.getMountOfSteps(elNum, 'left') - 1);\n          return true;\n        }\n      }\n      /* над эл много пространства и там мэл */\n      if (this.isMElOnTheSameRow(elNum) && (this.stepsToRight(elNum) >= 0)) { /* мэл в одной строке */\n        console.log('МЭЛ на одной строке и перед эл');\n        this.goMountOfSteps('right', this.getMountOfSteps(elNum, 'right') - 1);\n        this.goMountOfSteps('top', 1);\n        this.goMountOfSteps('right', 2);\n        this.goMountOfSteps('bottom', 1);\n        return true;\n      }\n      /* Common */\n      if (this.stepsToBottom(elNum) >= 0) { /* (вниз) */\n        this.goMountOfSteps('bottom', this.getMountOfSteps(elNum, 'bottom') - 1);\n        returnFlag = true;\n      }\n      if (this.isMElOnTheSameCol(elNum)) {\n        this.goMountOfSteps('right', 1);\n        this.goMountOfSteps('bottom', 1);\n        return true;\n      }\n      if (this.stepsToRight(elNum) >= 0) { /* (вправо) */\n        this.goMountOfSteps('right', this.getMountOfSteps(elNum, 'right') + 1);\n        // this.goMountOfSteps('top', 1);\n        // this.goMountOfSteps('right', 2);\n        console.log('testing ------------');\n        this.goMountOfSteps('bottom', 1);\n        returnFlag = true;\n      }\n      if (this.stepsToLeft(elNum) >= 0) { /* (влево) */\n        this.goMountOfSteps('left', this.getMountOfSteps(elNum, 'left') - 1);\n        this.goMountOfSteps('bottom', 1);\n        returnFlag = true;\n      }\n    } else {\n      /* 3-я и 4-я четверти */\n      if (this.isMElOnTheSameRow(elNum) && (this.stepsToLeft(elNum) >= 0)) { /* гэл в одной строке */\n        this.goMountOfSteps('left', this.getMountOfSteps(elNum, 'left') - 1);\n        return true;\n      }\n      if (this.isMElOnTheSameCol(elNum) && (this.isMElCanMoveToTheRight())) { /* гэл в одной колонке обход последнего элемента не должен происходить */\n        this.goMountOfSteps('right', 1);\n        this.goMountOfSteps('top', this.getMountOfSteps(elNum, 'top'));\n        return true;\n      }\n      // if ((this.matrix[elNum - 1].x <= this.getXPXPosition(elNum)) && (this.matrix[elNum - 1].y - this.getOffset() === this.getYPXPosition(elNum))) {\n      /* если элемент стоит под уже установленной строкой, то обходить только снизу, чтобы не испортить позицию предыдущих элов */\n      //   if (this.stepsTotop(elNum) >= 0) { /* (вверх) */\n      //     this.goMountOfSteps('top', this.getMountOfSteps(elNum, 'top') - 1);\n      //   }\n      //   if (this.stepsToRight(elNum) >= 0) { /* (вправо) */\n      //     this.goMountOfSteps('right', this.getMountOfSteps(elNum, 'right'));\n      //   }\n      //   if (this.stepsToLeft(elNum) >= 0) { /* (влево) */\n      //     this.goMountOfSteps('left', this.getMountOfSteps(elNum, 'left'));\n      //   }\n      //   this.goMountOfSteps('right', 1);\n      //   this.goMountOfSteps('top', 2);\n      //   this.goMountOfSteps('left', 1);\n      //   return;\n      // }\n      if (this.stepsTotop(elNum) >= 0) { /* (вверх) */\n        this.goMountOfSteps('top', this.getMountOfSteps(elNum, 'top') - 1);\n        returnFlag = true;\n      }\n      if (this.stepsToRight(elNum) >= 0) { /* (вправо) */\n        this.goMountOfSteps('right', this.getMountOfSteps(elNum, 'right'));\n        returnFlag = true;\n      }\n      if (this.stepsToLeft(elNum) >= 0) { /* (влево) */\n        this.goMountOfSteps('left', this.getMountOfSteps(elNum, 'left'));\n        returnFlag = true;\n      }\n      // this.goMountOfSteps('left', 1);\n      if (returnFlag) {\n        this.goMountOfSteps('right', 1);\n        this.goMountOfSteps('top', 1);\n      }\n    }\n    return returnFlag;\n  }\n\n  /**\n  *  @private Prepeare Steps (saves in stepMatrix)\n  *\n  * @param {number} el number of element inMatrix\n  * @param {number} stepDirection direction: 1-top, 2-right, 3-bottom, 4-left\n  * @returns {void}\n  */\n  addStep(el, stepDirection) {\n    this.stepMatrix.push([el, stepDirection]);\n  }\n\n  makeStep(dir, elNum = this.mainElNum) {\n    switch (dir) {\n      case 1:\n      case 'top':\n        /* шагнуть главным элементом вверх */\n        // console.log(`позиция el над главным ${this.getTopCurrentElNum(this.mainElNum)}`);\n        this.setShffldOnElNumAndGooo(elNum, 'top');\n        break;\n      case 2:\n      case 'right':\n        /* шагнуть главным элементом вправо */\n        // console.log(`позиция el справа от главного ${this.getRightCurrentElNum(this.mainElNum)}`);\n        this.setShffldOnElNumAndGooo(elNum, 'right');\n        break;\n      case 3:\n      case 'bottom':\n        /* шагнуть главным элементом вниз */\n        // console.log(`позиция el под главным ${this.getBottomCurrentElNum(this.mainElNum)}`);\n        this.setShffldOnElNumAndGooo(elNum, 'bottom');\n        break;\n      case 4:\n      case 'left':\n        /* шагнуть главным элементом влево */\n        // console.log(`позиция el слева от главного ${this.getLeftCurrentElNum(this.mainElNum)}`);\n        if (elNum !== this.mainElNum) {\n          if (this.isDrggblToLeft(elNum)) {\n            this.setShffldOnElNumAndGooo(elNum);\n            break;\n          }\n        }\n        this.setShffldOnElNumAndGooo(elNum);\n        break;\n      default:\n    }\n  }\n\n  getMountOfSteps(elNum, dir) {\n    switch (dir) {\n      case 'top':\n        return this.getElRowNum(this.mainElNum) - this.getElRowNum(elNum);\n      case 'right':\n        return this.getElColNum(elNum) - this.getElColNum(this.mainElNum);\n      case 'bottom':\n        return this.getElRowNum(elNum) - this.getElRowNum(this.mainElNum);\n      case 'left':\n        return this.getElColNum(this.mainElNum) - this.getElColNum(elNum);\n      default:\n        return false;\n    }\n  }\n\n  goMountOfSteps(dir, mount) {\n    for (let i = 0; i < mount; i++) {\n      switch (dir) {\n        case 'top':\n          this.addStep(this.mainElNum, 1);\n          break;\n        case 'right':\n          this.addStep(this.mainElNum, 2);\n          break;\n        case 'bottom':\n          this.addStep(this.mainElNum, 3);\n          break;\n        case 'left':\n          this.addStep(this.mainElNum, 4);\n          break;\n        default:\n      }\n    }\n  }\n\n  getElRowNum(elNum) {\n    return ((this.matrix[elNum - 1].y) / this.getOffset()) + 1;\n  }\n\n  getElColNum(elNum) {\n    return ((this.matrix[elNum - 1].x) / this.getOffset()) + 1;\n  }\n\n  isMElBefore(elNum) {\n    return this.getCurrentElNumN(this.mainElNum) < this.getCurrentElNumN(elNum);\n  }\n\n  isOnPropRow(elNum) {\n    return this.isElOnPropPosY(elNum);\n  }\n\n  isOnPropCol(elNum) {\n    return this.isElOnPropPosX(elNum);\n  }\n\n  isMElOnTheSameRow(elNum) {\n    return this.matrix[this.mainElNum - 1].y === this.matrix[elNum - 1].y;\n  }\n\n  isMElOnTheSameCol(elNum) {\n    return this.matrix[this.mainElNum - 1].x === this.matrix[elNum - 1].x;\n  }\n\n  isMElCanMoveToTheRight() {\n    return (this.getCurrentElNumN(this.mainElNum) % this.matrixDimensionX) !== 0;\n  }\n\n  isMElCanMoveToTheLeft() {\n    return ((this.getCurrentElNumN(this.mainElNum) - 1) % this.matrixDimensionX) !== 0;\n  }\n\n  isMElCanMoveToTheTop() {\n    return this.matrix[this.mainElNum - 1].y !== 0;\n  }\n\n  isMElCanMoveToTheBottom() {\n    return this.matrix[this.mainElNum - 1].y < ((this.matrixDimensionY - 1) * this.getOffset());\n  }\n\n  isThereAbilityToGoByBottom(elNum) {\n    return this.matrix[elNum - 1].y < ((this.matrixDimensionY - 1) * this.getOffset());\n  }\n\n  isDrgbl(elNum, dir) {\n    switch (dir) {\n      case 1:\n      case 'top':\n        return this.isDrggblToTop(elNum);\n      case 2:\n      case 'right':\n        return this.isDrggblToRight(elNum);\n      case 3:\n      case 'bottom':\n        return this.stepsToBottom(elNum);\n      case 4:\n      case 'left':\n        return this.isDrggblToLeft(elNum);\n      default:\n    }\n    return false;\n  }\n\n  isMelDrgbl(dir) {\n    switch (dir) {\n      case 1:\n      case 'top':\n        return this.isMElCanMoveToTheTop();\n      case 2:\n      case 'right':\n        return this.isMElCanMoveToTheRight();\n      case 3:\n      case 'bottom':\n        return this.isMElCanMoveToTheBottom();\n      case 4:\n      case 'left':\n        return this.isMElCanMoveToTheLeft();\n      default:\n    }\n    return false;\n  }\n\n  isDrggblToTop(elNum) {\n    return this.isElMain(this.getTopElNum(elNum));\n  }\n\n  isDrggblToBottom(elNum) {\n    return this.isElMain(this.getBottomElNum(elNum));\n  }\n\n  isDrggblToLeft(elNum) {\n    return this.isElMain(this.getLeftElNum(elNum));\n  }\n\n  isDrggblToRight(elNum) {\n    return this.isElMain(this.getRightElNum(elNum));\n  }\n\n  stepsToBottom(elNum) {\n    return (this.getMountOfSteps(elNum, 'bottom') - 1);\n  }\n\n  stepsTotop(elNum) {\n    return (this.getMountOfSteps(elNum, 'top') - 1);\n  }\n\n  stepsToRight(elNum) {\n    return (this.getMountOfSteps(elNum, 'right') - 1);\n  }\n\n  stepsToLeft(elNum) {\n    return (this.getMountOfSteps(elNum, 'left') - 1);\n  }\n\n  /**\n   * @private compute and set stepMatrix function\n   * @param {number} elNum element number\n   * @param {number} leftRightTopBottom 1-left, 2-right, 3-top, 4-bottom\n   * @param {number} mode  1-horisontal, 2-vertical (order: top-bottom-left)\n   */\n  stepsCompute(elNum, leftRightTopBottom, mode) {\n    // if (this.mainElNum === elNum) {\n    //   console.log(`${this.mainElNum} === ${elNum}`);\n    //   return false;\n    // }\n    this.setCurrentMatrixN();\n    if (this.isElOnPropPos(elNum)) {\n      // console.log('ON PROP POS');\n      return true;\n    }\n    switch (this.getPropDir(leftRightTopBottom, mode)) {\n      case 1:\n        // console.log('                 ----====== TOP ======------');\n        this.toTop(elNum, mode);\n        break;\n      case 2:\n        // console.log('                 ----====== RIGHT ======------');\n        this.toRight(elNum, mode);\n        break;\n      case 3:\n        // console.log('                 ----====== BOTTOM ======------');\n        this.toBottom(elNum, mode);\n        break;\n      case 4:\n        // console.log('                 ----====== LEFT ======------');\n        this.toLeft(elNum, mode);\n        break;\n      default:\n    }\n    return false;\n  }\n\n  getPropDir(leftRightTopBottom, mode) {\n    if (mode === 2) {\n      switch (leftRightTopBottom) {\n        case 1:\n          return 1;\n        case 2:\n          return 3;\n        case 3:\n          return 4;\n        default:\n      }\n    }\n    switch (leftRightTopBottom) {\n      case 1:\n        return 4;\n      case 2:\n        return 2;\n      case 3:\n        return 1;\n      default:\n    }\n    return false;\n  }\n\n  araseMatrix() {\n    this.matrix = [];\n  }\n\n  setDimentionXY(x) {\n    this.matrixDimensionX = x || this.defaultDimension;\n    this.matrixDimensionY = this.matrixDimensionX;\n    this.setMainElNum();\n  }\n\n  getElObj(elNum) {\n    return {\n      x: this.getXPXPosition(elNum),\n      y: this.getYPXPosition(elNum),\n      ownNum: elNum,\n      isMain: elNum === this.getMatrixDimension(),\n    };\n  }\n\n  getXInitElementPosInsideMatrix(elNum) {\n    return (elNum - 1) % this.matrixDimensionX;\n  }\n\n  getYInitElementPosInsidMatrix(elNum) {\n    return parseInt((elNum - 1) / this.matrixDimensionX, 10);\n  }\n\n  getYPXPosition(elNum) {\n    return this.getYInitElementPosInsidMatrix(elNum) * this.getOffset();\n  }\n\n  getXPXPosition(elNum) {\n    return this.getXInitElementPosInsideMatrix(elNum) * this.getOffset();\n  }\n\n  setPosY(elNum, _y) {\n    this.matrix[elNum - 1].y = _y;\n  }\n\n  setPosX(elNum, _x) {\n    this.matrix[elNum - 1].x = _x;\n  }\n\n  setMatrixDimensionX(dimension) {\n    this.matrixDimensionX = dimension;\n  }\n\n  getMatrixDimension() {\n    return this.matrixDimensionX * this.matrixDimensionY;\n  }\n\n  setMainElNum() {\n    this.mainElNum = this.getMatrixDimension();\n  }\n\n  getMainElID() {\n    return `elID_${this.mainElNum}`;\n  }\n\n  addElObjToMatrix(elNum) {\n    this.matrix.push(this.getElObj(elNum));\n  }\n\n  makeShuffledMatrix() {\n    for (let i = 1, l = this.getMatrixDimension(); i <= l; i++) {\n      this.shuffledMatrix.push(i);\n    }\n    this.shuffledMatrix.sort(() => Math.random() - 0.5);\n  }\n\n  makeAllObj() {\n    this.makeShuffledMatrix();\n    for (let i = 1, l = this.getMatrixDimension(); i <= l; i++) {\n      this.addElObjToMatrix(i);\n    }\n  }\n\n  getElLeftTopCSSProp(elNum) {\n    return `left: ${this.getXPXPosition(elNum)}px; top: ${this.getYPXPosition(elNum)}px;`;\n  }\n\n  getElBgPosCSSProp(elNum) {\n    return `${this.getBackGroundSizeCSS()} background-position: -${this.getXPXPosition(elNum)}px -${this.getYPXPosition(elNum)}px;`;\n  }\n\n  isElMain(elNum) {\n    return elNum ? this.matrix[elNum - 1].isMain : false;\n  }\n\n  getElNumViaLeftTopPos(left, top) {\n    try {\n      return this.matrix.find((el) => (el.x === left && el.y === top)).ownNum;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  getPosX(elNum) {\n    return this.matrix[elNum - 1].x;\n  }\n\n  getPosY(elNum) {\n    return this.matrix[elNum - 1].y;\n  }\n\n  getTopElNum(elNum) {\n    return this.getElNumViaLeftTopPos(this.getPosX(elNum), this.getPosY(elNum) - this.getOffset());\n  }\n\n  getRightElNum(elNum) {\n    return this.getElNumViaLeftTopPos(this.getPosX(elNum) + this.getOffset(), this.getPosY(elNum));\n  }\n\n  getBottomElNum(elNum) {\n    return this.getElNumViaLeftTopPos(this.getPosX(elNum), this.getPosY(elNum) + this.getOffset());\n  }\n\n  getLeftElNum(elNum) {\n    return this.getElNumViaLeftTopPos(this.getPosX(elNum) - this.getOffset(), this.getPosY(elNum));\n  }\n\n  render() {\n    this.makeNoMatrixElmnts();\n    this.showMatrix();\n    this.mainUsrController();\n  }\n\n  /*  Timer  */\n  startTimer() {\n    this.isPaused = false;\n    const timerVal = this.getTimerVal() ? this.getTimerVal().split(\":\") : false;\n    let sec = timerVal ? parseInt(timerVal[2], 10) : 0;\n    let min = timerVal ? parseInt(timerVal[1], 10) : 0;\n    let hr = timerVal ? parseInt(timerVal[0], 10) : 0;\n    // const shift = 0;// this.getTimerResult();\n    // const start\t= Date.now();\n    const obResult = this.timer;\n\n    this.timerID = setInterval(() => {\n      sec += 1;\n      if (sec >= 60) {\n        min += 1;\n        sec = 0;\n      }\n      if (min >= 60) {\n        hr += 1;\n        min = 0;\n      }\n      obResult.innerText = `${hr.toString().length < 2 ? `0${hr}` : hr}:${min.toString().length < 2 ? `0${min}` : min}:${sec.toString().length < 2 ? `0${sec}` : sec}`;\n    }, 1000);\n  }\n\n  getTimerVal() {\n    return this.timerVal;\n  }\n\n  setTimerVal() {\n    this.timerVal = this.timer.innerText;\n  }\n\n  resetTimer() {\n    this.timerVal = null;\n    this.startTimer();\n  }\n\n  pauseGame() {\n    if (!this.isPaused) {\n      this.isPaused = true;\n      this.setTimerVal();\n      clearInterval(this.timerID);\n      // console.log('paused');\n      return;\n    }\n    this.isPaused = false;\n    this.startTimer();\n  }\n\n  /*\n    View\n  */\n\n  /* cssRules ID */\n  setStyleSheet() {\n    if (this.styleSheet !== null) {\n      return;\n    }\n    const ss = document.styleSheets;\n    for (let i = 0, ssLngth = ss.length; i < ssLngth; i++) {\n      for (let j = 0, rulesLngth = ss[i].cssRules.length; j < rulesLngth; j++) {\n        if (ss[i].cssRules[j].selectorText === '.main-container') {\n          this.styleSheet = ss[i];\n          return;\n        }\n      }\n    }\n  }\n\n  /* important to feat */\n  getClassRule(selector) {\n    for (let j = 0, l = this.styleSheet.cssRules.length; j < l; j++) {\n      if (this.styleSheet.cssRules[j].selectorText === selector) {\n        return this.styleSheet.cssRules[j];\n      }\n    }\n    return false;\n  }\n\n  setClassRule(selector, styles) {\n    if (!this.getClassRule(selector)) {\n      this.styleSheet.insertRule(`${selector}{}`, this.styleSheet.cssRules.length); // ${styles}\n    }\n    this.getClassRule(selector).style.cssText = styles;\n    // console.log(this.getClassRule(selector).style.cssText);\n  }\n\n  setCSSProperty(selector, prop, val) {\n    if (!this.getClassRule(selector)) {\n      this.styleSheet.insertRule(`${selector}{}`, this.styleSheet.cssRules.length); // ${styles}\n    }\n    this.getClassRule(selector).style[prop] = val;\n    // console.log(this.getClassRule(selector).style[prop]);\n  }\n\n  changeCSSClass(el, pre, old, on) {\n    const OB = document.getElementById(el);\n    OB.classList.remove(pre + old);\n    OB.classList.add(pre + on);\n  }\n\n  makeAllParts() {\n    if (!this.mainContainer) {\n      this.el = this.createElNode('div', 'mainContainer', 'main-container pos');\n      this.setCSSProperty('.pos', `top`, `calc(50% - ${this.getBackGroundSize()}px/2)`);\n      this.setCSSProperty('.pos', `left`, `calc(50% - ${this.getBackGroundSize()}px/2)`);\n      // this.setClassRule('.pos', `top: calc(50% - ${this.getBackGroundSize()}px/2); left: calc(50% - ${this.getBackGroundSize()}px/2);`);\n      this.appendToMain(this.el);\n      this.mainContainer = document.getElementById('mainContainer');\n    }\n    this.makeAllObj();\n\n    this.matrix.forEach((elmnt) => {\n      this.setClassRule(`.cube-position${elmnt.ownNum}`, `${this.getElLeftTopCSSProp(elmnt.ownNum)}`);\n      this.setClassRule(`.cube-bg${elmnt.ownNum}`, this.getElCSS(elmnt.ownNum));\n      this.innerEl = document.createElement('div');\n      this.innerEl.id = `elID_${elmnt.ownNum}`;\n      this.innerEl.dataset.elNum = elmnt.ownNum;\n      this.innerEl.classList = `cube-position${elmnt.ownNum} cube-bg${elmnt.ownNum}`;\n      this.innerEl.textContent = elmnt.ownNum;\n      this.mainContainer.appendChild(this.innerEl);\n    });\n    // this.appendToMain(this.mainContainer);\n  }\n\n  createElNode(type, _id = '', _classList = '', _textContent = '', dataName = '', dataVal = '') {\n    const NODE = document.createElement(type);\n    if (_id !== '') {\n      NODE.id = _id;\n    }\n    if (dataName !== '') {\n      NODE.dataset[dataName] = dataVal;\n    }\n    if (_classList !== '') {\n      NODE.classList = _classList;\n    }\n    if (_textContent !== '') {\n      NODE.textContent = _textContent;\n    }\n    return NODE;\n  }\n\n  appendToMain(node) {\n    if (!this.mainEl) {\n      this.mainEl = document.getElementById('main');\n    }\n    this.mainEl.appendChild(node);\n  }\n\n  makeDimensionSelect() {\n    const SELECT = this.createElNode('select', 'dimSelect', 'selects');\n    Object.keys(this.isMobile ? this.dem.mobile : this.dem.desktop).forEach((el) => {\n      this.el = this.createElNode('option', '', '', `${el}x${el}`, 'dim', el);\n      if (el.toString() === this.defaultDimension.toString()) {\n        this.el.selected = true;\n      }\n      SELECT.appendChild(this.el);\n    });\n    this.sattingsBoardContainer.appendChild(SELECT);\n  }\n\n  makeImagesSelect() {\n    const SELECT = this.createElNode('select', 'imgSelect', 'selects');\n    for (let el = 1; el <= this.img.imagesAmount; el++) {\n      this.el = this.createElNode('option', '', '', `image ${el}`, 'dim', el);\n      // if (el.toString() === this.defaultDimension.toString()) {\n      //   this.el.selected = true;\n      // }\n      SELECT.appendChild(this.el);\n    }\n    this.sattingsBoardContainer.appendChild(SELECT);\n  }\n\n  makeHeader() {\n    this.appendToMain(this.createElNode('h1', '', '', this.string[this.lang].gemPuzzle));\n  }\n\n  makeResetBtn() {\n    this.gameBoardContainer.appendChild(this.createElNode('div', 'resetBtn', 'btn centered', this.string[this.lang].resetBtn));\n  }\n\n  makeGameDashBoard() {\n    this.appendToMain(this.createElNode('div', 'dashBoardContainer', 'dash dash-pos'));\n    const w = this.getBackGroundSize();\n    this.setClassRule('.dash-pos', `width: ${w}px; left: calc(50% - ${w}px/2); top: calc(50% - ${w - (w > 320 ? 180 : 120)}px);`);\n    this.dashBoardContainer = document.getElementById('dashBoardContainer');\n  }\n\n  makeSettingsDash() {\n    this.appendToMain(this.createElNode('div', 'sattingsBoardContainer', 'dash sattings-board-container'));\n    this.sattingsBoardContainer = document.getElementById('sattingsBoardContainer');\n  }\n\n  makeGameDash() {\n    this.appendToMain(this.createElNode('div', 'gameBoardContainer', 'dash sattings-board-container game-top-mod'));\n    this.gameBoardContainer = document.getElementById('gameBoardContainer');\n  }\n\n  makeTimer() {\n    this.dashBoardContainer.appendChild(this.createElNode('div', 'timer', 'centered', '00:00:00'));\n    this.timer = document.getElementById('timer');\n  }\n\n  makeStopStartTimerBtn() {\n    this.dashBoardContainer.appendChild(this.createElNode('div', 'stopStartBtn', 'btn centered', this.string[this.lang].startBtn));\n    this.stopStartBtn = document.getElementById('stopStartBtn');\n  }\n\n  makeStepNumber() {\n    this.dashBoardContainer.appendChild(this.createElNode('div', 'steps', 'centered', `${this.string[this.lang].step}0`));\n    this.stepCounterObj = document.getElementById('steps');\n  }\n\n  makeSaveBtn() {\n    this.gameBoardContainer.appendChild(this.createElNode('div', 'saveBtn', 'btn centered', this.string[this.lang].saveBtn));\n  }\n\n  makeLoadBtn() {\n    this.gameBoardContainer.appendChild(this.createElNode('div', 'loadBtn', 'btn centered', this.string[this.lang].loadBtn));\n  }\n\n  bestResBtn() {\n    this.gameBoardContainer.appendChild(this.createElNode('div', 'bestResBtn', 'btn centered', this.string[this.lang].bestResBtn));\n    this.bestResBtnObj = document.getElementById('bestResBtn');\n  }\n\n  makeIsSolvingHint() {\n    this.appendToMain(this.createElNode('div', 'solvingHint', 'solving-hint centered'));\n    this.solvingHint = document.getElementById('solvingHint');\n  }\n\n  makeIsWinHint() {\n    this.appendToMain(this.createElNode('div', 'winHint', 'win-hint centered'));\n    this.winHint = document.getElementById('winHint');\n  }\n\n  makeImagesDescribe() {\n    this.appendToMain(this.createElNode('div', 'imagesDescribe', 'win-hint images-describe centered'));\n    this.imagesDescribe = document.getElementById('imagesDescribe');\n  }\n\n  makeSoundBtn() {\n    this.sattingsBoardContainer.appendChild(this.createElNode('div', 'soundBtn', 'btn centered', this.string[this.lang].soundBtn));\n    this.soundBtn = document.getElementById('soundBtn');\n  }\n\n  makeSoundField() {\n    const soundEl = this.createElNode('audio', 'sound1', 'sound-1');\n    soundEl.src = 'sounds/sound1.wav';\n    this.appendToMain(soundEl);\n    this.soundObj = document.getElementById('sound1');\n  }\n\n  makeAIStepBtn() {\n    // makeAISteps(elNum);\n    this.dashBoardContainer.appendChild(this.createElNode('div', 'stepBtn', 'btn centered', this.string[this.lang].stepBtn));\n    this.stepBtn = document.getElementById('stepBtn');\n  }\n\n  makeAnimatedWindow() {\n    this.appendToMain(this.createElNode('div', 'animatedWindow', 'animated-window'));\n    this.animatedWindow = document.getElementById('animatedWindow');\n  }\n\n  makeLoadWindowInteraction() {\n    this.appendToMain(this.createElNode('div', 'loadWindowInteraction', 'interact-window'));\n    this.loadWindowInteraction = document.getElementById('loadWindowInteraction');\n  }\n\n  makeBestResultsWindow() {\n    this.appendToMain(this.createElNode('div', 'bestResultsWindow', 'interact-window'));\n    this.bestResultsWindow = document.getElementById('bestResultsWindow');\n  }\n\n  getElCSS(elNum) {\n    const z = (elNum === this.getMatrixDimension()) ? 'z-index: 0; opacity: 0;' : 'z-index: 1; opacity: 1;';\n    return `${this.getElBgPosCSSProp(elNum)} width: ${this.getOffset()}px; height: ${this.getOffset()}px; line-height: ${this.getOffset()}px; ${z}`;\n  }\n\n  makeNoMatrixElmnts() {\n    this.makeAnimatedWindow();\n\n    this.makeHeader();\n\n    this.makeSettingsDash();\n\n    this.makeDimensionSelect();\n    this.makeImagesSelect();\n\n    this.makeSoundBtn();\n    this.makeSoundField();\n\n    this.makeGameDash();\n\n    this.makeResetBtn();\n    this.makeSaveBtn();\n    this.makeLoadBtn();\n    this.bestResBtn();\n\n    this.makeGameDashBoard();\n    this.makeTimer();\n    // this.startTimer();\n    this.makeStopStartTimerBtn();\n    this.makeStepNumber();\n    this.makeAIStepBtn();\n\n    this.makeIsSolvingHint();\n    this.makeIsWinHint();\n    this.makeImagesDescribe();\n\n    this.makeLoadWindowInteraction();\n    this.makeBestResultsWindow();\n  }\n\n  showMatrix() {\n    this.makeAllParts();\n    this.shuffle();\n\n    document.querySelectorAll('[data-el-num]').forEach((el) => {\n      // console.log(el);\n      this.dragElementInit(el);\n    });\n  }\n\n  setAllPartsInItsPos() {\n    let ob;\n    this.matrix.forEach((el, i) => {\n      ob = document.getElementById(`elID_${i + 1}`);\n      this.setPosX(i + 1, this.getXPXPosition(i + 1));\n      this.setPosY(i + 1, this.getYPXPosition(i + 1));\n      ob.className = `wbrdr box-text-color cube-bg${i + 1}`;\n      ob.classList.add(`cube-position${i + 1}`);\n    });\n  }\n\n  // setCurrentMatrix() {\n  //   this.shuffledMatrix = [];\n  //   Object.keys(this.matrix).forEach((el, i) => {\n  //     this.shuffledMatrix.push(this.getCurrentElNum(this.matrix[i].x, this.matrix[i].y));\n  //   });\n  // }\n\n  isPairEven(start, el) {\n    for (let i = start, l = this.shuffledMatrix.length; i < l; i++) {\n      if (el > this.shuffledMatrix[i] && el !== this.getMatrixDimension()) {\n        this.shuffledMatrixEvenSumm += 1;\n        this.tempLog = `${this.tempLog}${el} > ${this.shuffledMatrix[i]}\\n`;\n      }\n    }\n  }\n\n  isShuffledMatrixSolving() {\n    this.shuffledMatrixEvenSumm = 0;\n    this.shuffledMatrix.forEach((el, i) => {\n      this.isPairEven(i, el);\n      this.tempLog = '';\n    });\n    if (this.getMatrixDimension() % 2 === 0) {\n      this.shuffledMatrixEvenSumm = this.shuffledMatrixEvenSumm + (this.matrix[this.getMatrixDimension() - 1].y / this.getOffset()) + 1;\n      // console.log((this.shuffledMatrixEvenSumm % 2 === 0) ? 'solving' : 'not solving');\n      return this.shuffledMatrixEvenSumm % 2 === 0;\n    }\n    // console.log('out '+ (this.shuffledMatrixEvenSumm % 2 !== 0));\n    // console.log((this.shuffledMatrixEvenSumm % 2 === 0) ? 'solving' : 'not solving');\n    return this.shuffledMatrixEvenSumm % 2 === 0;\n  }\n\n  shuffle(m = false) {\n    // console.log(this.shuffledMatrix);\n    this.shuffledMatrix.forEach((el, i) => {\n      // this.shuffleFn(i + 1, el);\n      // console.log(`elID_${el} c-pos${i + 1}`);\n      this.shuffleFnMakeStep(el, i + 1);\n    });\n    this.setCSSProperty(`.cube-bg${this.getMatrixDimension()}`, 'opacity', 0); // /(`.cube-bg${this.getMatrixDimension()}`, \"opacity: 0;\");\n    // this.setClassRule(`.cube-bg${this.getMatrixDimension()}`, \"opacity: 0;\");\n    if (!m) {\n      if (!this.isShuffledMatrixSolving()) {\n        this.resetShuffledMatrix();\n        // this.setAllPartsInItsPos();\n        // console.log('notsolving');\n        this.shuffle();\n        // this.solvingHint.innerText = this.isShuffledMatrixSolving() ? '' : 'warning! the pazzle can\\'t be solved';\n      }\n      this.winHint.innerText = '';\n      this.imagesDescribe.innerText = '';\n    }\n  }\n\n  shuffleFnMakeStep(elNum, shuffle) {\n    const ob = document.getElementById(`elID_${elNum}`);\n    ob.className = `wbrdr box-text-color cube-bg${elNum}`;\n    ob.classList.add(`cube-position${shuffle}`);\n    this.setPosX(elNum, this.getXPXPosition(shuffle));\n    this.setPosY(elNum, this.getYPXPosition(shuffle));\n    // console.log(`elNum${elNum} ${this.matrix[elNum - 1].x} ${this.matrix[elNum - 1].y}`);\n  }\n\n  resetShuffledMatrix() {\n    // this.repeated = [];\n    this.shuffledMatrix = [];\n    this.makeShuffledMatrix();\n    this.winHint.innerText = '';\n    this.imagesDescribe.innerText = '';\n  }\n\n  getCurrentElNum(elNum) {\n    return parseInt(this.getPosX(elNum) / this.getOffset(), 10) + 1 + parseInt(this.getPosY(elNum) / this.getOffset(), 10) * this.matrixDimensionY;\n  }\n\n  getRightCurrentElNum(elNum) {\n    return parseInt((this.getPosX(elNum) + this.getOffset()) / this.getOffset(), 10) + 1 + parseInt(this.getPosY(elNum) / this.getOffset(), 10) * this.matrixDimensionY;\n  }\n\n  getLeftCurrentElNum(elNum) {\n    return parseInt((this.getPosX(elNum) - this.getOffset()) / this.getOffset(), 10) + 1 + parseInt(this.getPosY(elNum) / this.getOffset(), 10) * this.matrixDimensionY;\n  }\n\n  getBottomCurrentElNum(elNum) {\n    return parseInt(this.getPosX(elNum) / this.getOffset(), 10) + 1 + parseInt((this.getPosY(elNum) + this.getOffset()) / this.getOffset(), 10) * this.matrixDimensionY;\n  }\n\n  getTopCurrentElNum(elNum) {\n    return parseInt(this.getPosX(elNum) / this.getOffset(), 10) + 1 + parseInt((this.getPosY(elNum) - this.getOffset()) / this.getOffset(), 10) * this.matrixDimensionY;\n  }\n\n  changDrgblClass(id, pred, curElNum, altElNum) {\n    this.changeCSSClass(id, pred, curElNum, altElNum);\n    this.changeCSSClass(this.getMainElID(), pred, altElNum, curElNum);\n  }\n\n  changeObPosVal(elNum) {\n    const mainElX = this.getPosX(this.getMatrixDimension());\n    const mainElY = this.getPosY(this.getMatrixDimension());\n    this.setPosX(this.getMatrixDimension(), this.getPosX(elNum));\n    this.setPosY(this.getMatrixDimension(), this.getPosY(elNum));\n    this.setPosX(elNum, mainElX);\n    this.setPosY(elNum, mainElY);\n    if (this.isUserWin() === 'win') {\n      // console.log('You win!');\n      this.winHint.innerText = `${this.string[this.lang].winSlug1} ${this.step} ${this.string[this.lang].winSlug2} ${document.getElementById('timer').innerText}`;\n      this.imagesDescribe.innerText = `${_modules_images__WEBPACK_IMPORTED_MODULE_0__.default[this.currentImage - 1].author}, ${_modules_images__WEBPACK_IMPORTED_MODULE_0__.default[this.currentImage - 1].name} ${_modules_images__WEBPACK_IMPORTED_MODULE_0__.default[this.currentImage - 1].year}`;\n      this.setCSSProperty(`.cube-bg${this.getMatrixDimension()}`, 'opacity', 1); // this.setClassRule(`.cube-bg${this.getMatrixDimension()}`, \"opacity: 1;\");\n      document.getElementById(this.getMainElID()).classList.add('animated');\n      document.querySelectorAll('[data-el-num]').forEach((el) => {\n        el.classList.remove(\"box-text-color\");\n        el.classList.add(\"box-text-color-trnsprnt\");\n        el.classList.remove('wbrdr');\n      });\n      this.setBestResLS(`{\"dim\":\"${this.matrixDimensionX}\", \"image\":\"${this.currentImage - 1}\", \"steps\":\"${this.step}\", \"time\":\"${document.getElementById('timer').innerText}\"}`);\n      this.isPaused = true;\n      clearInterval(this.timerID);\n    }\n    // this.winHint.innerText = 'You win! for '+this.step+' and '+document.getElementById('timer').innerText\n  }\n\n  setBestResLS(stringData) {\n    let data = localStorage.getItem(this.bestResDataKey);\n    /* not at all */\n    if (!data) {\n      // console.log(`/* not at all */`);\n      localStorage.setItem(this.bestResDataKey, `{\"0\":${stringData}}`);\n      // console.log(JSON.parse(localStorage.getItem(this.bestResDataKey)));\n      return;\n    }\n    data = JSON.parse(data);\n    let dataArr = Object.keys(data);\n    const savingData = JSON.parse(stringData);\n    /* less than 10 */\n    let countOfNodes = 0;\n    // if (dataArr.length <= this.bestResMax + 1) {}\n    let notRepeatedFlag = true;\n    dataArr.forEach((el, i) => {\n      if (data[i] && (data[i].dim === savingData.dim) && (data[i].steps === savingData.steps) && (data[i].time === savingData.time)) {\n        countOfNodes++;\n        notRepeatedFlag = false;\n      }\n    });\n    if (countOfNodes <= this.bestResMax) {\n      // console.log(`/* less than 10 */ ${countOfNodes}`);\n      data[dataArr.length] = savingData;\n      localStorage.setItem(this.bestResDataKey, JSON.stringify(data));\n      // console.log(JSON.parse(localStorage.getItem(this.bestResDataKey)));\n    }\n    // console.log(`notRepeatedFlag: ${notRepeatedFlag}`);\n    if (notRepeatedFlag) {\n      data[dataArr.length] = savingData;\n      localStorage.setItem(this.bestResDataKey, JSON.stringify(data));\n      // console.log(JSON.parse(localStorage.getItem(this.bestResDataKey)));\n      return;\n    }\n\n    /* compare data */\n    // console.log(`/* compare data */`);\n    let savedFlag = false;\n    let lastT;\n    dataArr.forEach((el, i) => {\n      if (data[i] && this.matrixDimensionX.toString() === data[i].dim) {\n        if (lastT === undefined) {\n          lastT = data[i].time;\n        }\n        lastT = this.compareTime(data[i].time, lastT) ? data[i].time : lastT;\n        // console.log(`lastT ${lastT}`);\n        if (this.compareTime(data[i].time, savingData.time) && !savedFlag) {\n          data[dataArr.length] = JSON.parse(stringData);\n          savedFlag = true;\n        }\n      }\n    });\n    // console.log(`FIN lastT ${lastT}`);\n    /* remove lastone */\n    if (lastT !== undefined && savedFlag) {\n      dataArr = Object.keys(data);\n      dataArr.forEach((el, i) => {\n        if (data[i] && this.matrixDimensionX.toString() === data[i].dim && data[i].time === lastT) {\n          delete data[i];\n        }\n      });\n    }\n    if (savedFlag) {\n      localStorage.setItem(this.bestResDataKey, JSON.stringify(data));\n      // console.log(JSON.parse(localStorage.getItem(this.bestResDataKey)));\n    }\n  }\n\n  compareTime(time, timeC) {\n    const t1 = time.split(':');\n    const t2 = timeC.split(':');\n    const c1 = new Date(2011, 0, 1, parseInt(t1[0], 10), parseInt(t1[1], 10), parseInt(t1[2], 10));\n    const c2 = new Date(2011, 0, 1, parseInt(t2[0], 10), parseInt(t2[1], 10), parseInt(t2[2], 10));\n    return c1.getTime() > c2.getTime();\n  }\n\n  getBestResLS() {\n    this.isBestResultsWindowActive = true;\n    const ob = JSON.parse(localStorage.getItem(this.bestResDataKey));\n    // console.log(ob);\n    this.bestResultsWindow.classList.add('displ-blck');\n    let brInnerHTML = `<h3 class=\"best-res-header centered\">THE BEST OF THE BEST (${this.matrixDimensionX}x${this.matrixDimensionX})</h3>`;\n    // const obKey = Object.keys(ob);\n    if (ob) {\n      Object.keys(ob).forEach((el, i) => {\n        // if (ob[i]) {\n        //   console.log(`${JSON.stringify(ob[i])}`);\n        // }\n        if (ob[i] && (this.matrixDimensionX.toString() === ob[i].dim)) {\n          // console.log(`this.matrixDimensionX ${this.matrixDimensionX.toString()} ${ob[i].dim} ${this.matrixDimensionX.toString() === ob[i].dim}`);\n          brInnerHTML += `<div class=\"best-res-item centered\">time: ${ob[i].time} steps: ${ob[i].steps}</div>`;\n        }\n      });\n    }\n    // let brInnerHTML = ''\n    this.bestResultsWindow.innerHTML = brInnerHTML;\n  }\n\n  loadGame(sets) {\n    // console.log(sets);\n    /* changing curr dimention */\n    if (typeof (sets) === 'object') {\n      clearInterval(this.timerID);\n      // this.resetTimer();\n      this.clearSteps();\n      // this.setDimentionXY(sets.dim);\n      // this.setMainElNum();\n      // this.setOffset();\n      // this.mainContainer.innerHTML = \"\";\n      // this.araseMatrix();\n      // this.resetShuffledMatrix();\n      // this.setAllPartsInItsPos();\n      // this.showMatrix();\n      this.shuffledMatrix = [];\n      this.shuffledMatrix = sets.matrix.split(',').map((el) => parseInt(el, 10));\n      this.shuffle();\n      this.step = parseInt(sets.steps, 10);\n      this.timerVal = sets.time;\n      this.timer.innerText = sets.time;\n      this.currentImage = parseInt(sets.image, 10) + 1;\n      this.setCSSProperty('.main-container div', `backgroundImage`, `url(\"../images/${this.currentImage}.jpg\")`);\n      this.imagesDescribe.innerText = '';\n    }\n    /* changing curr matrix */\n    /* changing curr image */\n    /* changing curr time */\n    /* changing curr step */\n  }\n\n  getSavedGamesLS() {\n    this.isSavedGamesWindowActive = true;\n    const ob = JSON.parse(localStorage.getItem(this.storeDataKey));\n    // console.log(ob);\n    this.loadWindowInteraction.classList.add('displ-blck');\n    let brInnerHTML = `<h3 class=\"best-res-header centered\">${this.string[this.lang].load} (${this.matrixDimensionX}x${this.matrixDimensionX})</h3>`;\n    if (ob) {\n      Object.keys(ob).forEach((el, i) => {\n        if (ob[i] && (this.matrixDimensionX.toString() === ob[i].dim)) {\n          brInnerHTML += `<div class=\"best-res-item centered\" data-set-game='${JSON.stringify(ob[i])}'>${ob[i].date}  image ${parseInt(ob[i].image, 10) + 1}</div>`;\n        }\n      });\n    }\n    this.loadWindowInteraction.innerHTML = `${brInnerHTML}<div id=\"closeLoadWindowInteractionBTN\" class=\"close-LoadWindowInteraction-BTN\">${this.string[this.lang].close}</div>`;\n  }\n\n  getStringForSaveGame(item = 0) {\n    const d = new Date();\n    const mth = d.getMonth().toString().length < 2 ? `0${d.getMonth()}` : d.getMonth();\n    const day = d.getDate().toString().length < 2 ? `0${d.getDate()}` : d.getDate();\n    const hr = d.getHours().toString().length < 2 ? `0${d.getHours()}` : d.getHours();\n    const mn = d.getMinutes().toString().length < 2 ? `0${d.getMinutes()}` : d.getMinutes();\n    const pre = item ? \"\" : `{\"${item}\":`;\n    const after = item ? \"\" : '}';\n    // eslint-disable-next-line max-len\n    return `${pre}{\"date\":\"${mth}-${day} ${hr}:${mn}\", \"dim\":\"${this.matrixDimensionX}\", \"image\":\"${this.currentImage - 1}\", \"steps\":\"${this.step}\", \"time\":\"${document.getElementById('timer').innerText}\", \"matrix\":\"${this.shuffledMatrix}\"}${after}`;\n  }\n\n  setCurrentGameLS() {\n    this.setCurrentMatrixN();\n    let data = localStorage.getItem(this.storeDataKey);\n    if (data === undefined || data === null) {\n      localStorage.setItem(this.storeDataKey, this.getStringForSaveGame());\n      // console.log(`UNDEFINED ${JSON.parse(localStorage.getItem(this.storeDataKey))}`);\n    }\n\n    if (data) {\n      data = JSON.parse(data);\n      const dataArr = Object.keys(data);\n      let lastDate = '';\n      let savedFlag = false;\n      let countOfNodes = 0;\n      dataArr.forEach((el, i) => {\n        if (data[i] && (data[i].dim === this.matrixDimensionX.toString())) {\n          // console.log('woohoo');\n          countOfNodes++;\n        }\n      });\n      if (countOfNodes >= 10) {\n        // console.log(`/* more then 10 */`);\n        /* find last day min ... */\n        dataArr.forEach((el, i) => {\n          if (lastDate === '') {\n            lastDate = data[i].date;\n          }\n          lastDate = this.compareDateAndTime(data[i].date, lastDate) ? data[i].date : lastDate;\n        });\n        /* removing old data */\n        if (lastDate !== '') {\n          dataArr.forEach((el, i) => {\n            if (data[i].date === lastDate && !savedFlag) {\n              data[i] = JSON.parse(this.getStringForSaveGame('get'));\n              savedFlag = true;\n            }\n          });\n        }\n      }\n      if (!savedFlag) {\n        data[dataArr.length] = JSON.parse(this.getStringForSaveGame('get'));\n      }\n      localStorage.setItem(this.storeDataKey, JSON.stringify(data));\n      // console.log(`JAST saved ${JSON.stringify(data)}`);\n    }\n    // console.log(JSON.parse(localStorage.getItem(this.storeDataKey)));\n  }\n\n  compareDateAndTime(datef, datesC) {\n    const date = datef.split(' ');\n    const dateC = datesC.split(' ');\n    const md1 = date[0].split('-');\n    const md2 = dateC[1].split('-');\n\n    const hm1 = dateC[1].split(':');\n    const hm2 = dateC[1].split(':');\n    const c1 = new Date(2011, parseInt(md1[0], 10), parseInt(md1[1], 10), parseInt(hm1[0], 10), parseInt(hm1[1], 10));\n    const c2 = new Date(2011, parseInt(md2[0], 20), parseInt(md2[1], 10), parseInt(hm2[0], 10), parseInt(hm2[1], 10));\n    return c1.getTime() > c2.getTime();\n  }\n\n  isElOnPropPosX(elNum) {\n    return this.matrix[elNum - 1].x === this.getXPXPosition(elNum);\n  }\n\n  isElOnPropPosY(elNum) {\n    return this.matrix[elNum - 1].y === this.getYPXPosition(elNum);\n  }\n\n  isElOnPropPos(elNum) {\n    return this.isElOnPropPosX(elNum) && this.isElOnPropPosY(elNum);\n  }\n\n  isUserWin() {\n    if (this.isElOnPropPos(this.getMatrixDimension())) {\n      for (let i = 0, l = this.matrix.length; i < l; i++) {\n        if (!this.isElOnPropPos(i + 1)) {\n          return false;\n        }\n      }\n      return 'win';\n    }\n    return false;\n  }\n\n  clearSteps() {\n    this.step = 0;\n    this.stepCounterObj.innerText = `${this.string[this.lang].step}0`;\n  }\n\n  changeStepCountNum() {\n    this.step += 1;\n    this.stepCounterObj.innerText = `${this.string[this.lang].step}${this.step}`;\n  }\n\n  /*\n    Controller\n  */\n  dragElementInit(_ob) {\n    // if (this.isPaused) {\n    //   return;\n    // }\n    const ob = _ob;\n    let tx = 0;\n    let ty = 0;\n\n    function elementDrag(e) {\n      ob.style.zIndex = '9999';\n      ob.style.top = `${e.pageY - ty / 2 + 160}px`;\n      ob.style.left = `${e.pageX - tx / 2 + 160}px`;\n    }\n\n    function closeDragElement() {\n      ob.removeAttribute('style');\n      document.onmouseup = null;\n      document.onmousemove = null;\n      document.ontouchend = null;\n      document.ontouchmove = null;\n    }\n\n    function dragMouseDown() {\n      tx = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n      ty = window.innerHeight || document.documentElement.clientHinnerHeight || document.body.clientHinnerHeight;\n      document.onmouseup = closeDragElement;\n      document.onmousemove = elementDrag;\n    }\n\n    if (ob) {\n      ob.onmousedown = dragMouseDown;\n      // ob.ontouchstart = dragTstart;\n    }\n\n    // function dragTstart(e) {\n    // // cl('Draaag!!!');\n    //   e = e || window.event;\n    //   // e.preventDefault();\n    //   ofsetX = e.targetTouches[0].pageX - ob.offsetLeft;\n    //   ofsetY = e.targetTouches[0].pageY - ob.offsetTop;\n    //   document.ontouchend = closeDragElement;\n    //   // document.ontouchmove = elementTDrag;\n    // }\n\n    // function elementTDrag(e) {\n    //   e = e || window.event;\n    //   // e.preventDefault();\n    //   tx = e.targetTouches[0].pageX - ofsetX;\n    //   ty = e.targetTouches[0].pageY - ofsetY;\n    //   ob.style.left = `${tx}px`;\n    //   ob.style.top = `${ty}px`;\n    //   console.log(`cstmzr7296 touch xy(${tx},${ty})`);\n    // }\n  }\n\n  mainUsrController() {\n    const CNTX = this;\n    function controlIt(e) {\n      if (CNTX.isBestResultsWindowActive) {\n        CNTX.isBestResultsWindowActive = false;\n        CNTX.bestResultsWindow.classList.remove('displ-blck');\n      }\n      if (e.target.id === 'resetBtn') {\n        CNTX.resetShuffledMatrix();\n        CNTX.setAllPartsInItsPos();\n        CNTX.shuffle();\n        clearInterval(CNTX.timerID);\n        CNTX.resetTimer();\n        CNTX.clearSteps();\n        return;\n      }\n      if (e.target.id === 'soundBtn') {\n        CNTX.soundBtn.innerText = CNTX.isSound ? CNTX.string[CNTX.lang].soundBtnOFF : CNTX.string[CNTX.lang].soundBtn;\n        CNTX.isSound = !CNTX.isSound; /* kind of CNTX.isSound = CNTX.isSound ? false : true; */\n        // console.log('sound');\n        return;\n      }\n      if (e.target.id === 'stepBtn') {\n        CNTX.isAutoMode = !CNTX.isAutoMode; /* kind of CNTX.isAutoMode = CNTX.isAutoMode ? false : true; */\n        if (CNTX.isAutoMode) {\n          CNTX.makeAISteps();\n        }\n        return;\n      }\n      if (e.target.id === 'saveBtn') {\n        // console.log('saveBTN');\n        CNTX.setCurrentGameLS();\n        return;\n      }\n      if (e.target.id === 'loadBtn') {\n        // console.log('loaded');\n        CNTX.getSavedGamesLS();\n        // console.log(localStorage.getItem(CNTX.storeDataKey));\n        return;\n      }\n      if (e.target.id === 'closeLoadWindowInteractionBTN' && CNTX.isSavedGamesWindowActive) {\n        CNTX.isSavedGamesWindowActive = false;\n        CNTX.loadWindowInteraction.classList.remove('displ-blck');\n      }\n      if (e.target.dataset.setGame) {\n        CNTX.loadGame(JSON.parse(e.target.dataset.setGame));\n      }\n      if (e.target.id === 'bestResBtn') {\n        // console.log('show Best Results Btn');\n        CNTX.getBestResLS();\n        return;\n      }\n      if (e.target.id === 'stopStartBtn') {\n        CNTX.stopStartBtn.innerText = CNTX.isPaused ? CNTX.string[CNTX.lang].stopBtn : CNTX.string[CNTX.lang].startBtn;\n        CNTX.pauseGame();\n        return;\n      }\n\n      if (!e.target.dataset.elNum) {\n        return;\n      }\n\n      const elNum = e.target.dataset.elNum;\n      // const x = CNTX.getPosX(elNum);\n      // const y = CNTX.getPosY(elNum);\n      const curElNum = CNTX.getCurrentElNum(elNum);\n\n      // if (e.target.dataset.elNum === CNTX.getMatrixDimension().toString()) {\n      //   console.log(\"Main\\n\");\n      //   CNTX.matrix.forEach((element) => {\n      // console.log(element);\n      //   });\n      //   return;\n      // }\n      if (CNTX.isPaused) {\n        return;\n      }\n      if (CNTX.isDrggblToTop(elNum)) {\n        // console.log('Top');\n        CNTX.changeStepCountNum();\n        const topCurrentEl = CNTX.getTopCurrentElNum(elNum);\n        CNTX.changDrgblClass(e.target.id, 'cube-position', curElNum, topCurrentEl);\n        CNTX.changeObPosVal(elNum);\n        if (CNTX.isSound) {\n          CNTX.soundObj.play();\n        }\n        return;\n      }\n      if (CNTX.isDrggblToBottom(elNum)) {\n        // console.log('Bottom');\n        CNTX.changeStepCountNum();\n        const bottomCurrentEl = CNTX.getBottomCurrentElNum(elNum);\n        CNTX.changDrgblClass(e.target.id, 'cube-position', curElNum, bottomCurrentEl);\n        CNTX.changeObPosVal(elNum);\n        if (CNTX.isSound) {\n          CNTX.soundObj.play();\n        }\n        return;\n      }\n      if (CNTX.isDrggblToRight(elNum)) {\n        // console.log('Right');\n        CNTX.changeStepCountNum();\n        const rightCurrentEl = CNTX.getRightCurrentElNum(elNum);\n        CNTX.changDrgblClass(e.target.id, 'cube-position', curElNum, rightCurrentEl);\n        CNTX.changeObPosVal(elNum);\n        if (CNTX.isSound) {\n          CNTX.soundObj.play();\n        }\n        return;\n      }\n      if (CNTX.isDrggblToLeft(elNum)) {\n        // console.log('Left');\n        CNTX.changeStepCountNum();\n        const leftCurrentEl = CNTX.getLeftCurrentElNum(elNum);\n        CNTX.changDrgblClass(e.target.id, 'cube-position', curElNum, leftCurrentEl);\n        CNTX.changeObPosVal(elNum);\n        if (CNTX.isSound) {\n          CNTX.soundObj.play();\n        }\n      }\n\n      // console.log(\"\\n\\n\");\n\n      // console.log(bottomCurrentEl);\n      // console.log(`isDrggblToTop:${CNTX.isDrggblToTop(elNum)}`);\n      // console.log(`isDrggblToRight:${CNTX.isDrggblToRight(elNum)}`);\n      // console.log(`isDrggblToBottom:${CNTX.isDrggblToBottom(elNum)}`);\n      // console.log(`isDrggblToLeft:${CNTX.isDrggblToLeft(elNum)}`);\n\n      // console.log(curElNum);\n      // console.log(rightCurrentEl);\n      // console.log(leftCurrentEl);\n      // console.log(bottomCurrentEl);\n      // console.log(topCurrentEl);\n\n      // const mainElY = CNTX.getPosY(CNTX.getMatrixDimension());\n      // const mainElX = CNTX.getPosX(CNTX.getMatrixDimension());\n      // CNTX.setPosY(CNTX.getMatrixDimension(), CNTX.getPosY(elNum));\n      // CNTX.setPosX(CNTX.getMatrixDimension(), CNTX.getPosX(elNum));\n      // CNTX.setPosY(elNum, mainElY);\n      // CNTX.setPosX(elNum, mainElX);\n    }\n\n    function controllerMoblTabltDsckVer() {\n      const w = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n      // const h = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n      if (w < 480) {\n        // console.log(w);\n        CNTX.isMobile = true;\n        CNTX.setOffset();\n      } else if (CNTX.isMobile) {\n        CNTX.isMobile = false;\n        CNTX.setOffset();\n      }\n    }\n\n    function controlSelect(e) {\n      if (e.target.id === 'dimSelect') {\n        // console.log(`${e.target.options[e.target.selectedIndex].value} ${e.target.options[e.target.selectedIndex].dataset.dim}`);\n        clearInterval(CNTX.timerID);\n        CNTX.resetTimer();\n        CNTX.clearSteps();\n        CNTX.setDimentionXY(e.target.options[e.target.selectedIndex].dataset.dim);\n        CNTX.setMainElNum();\n        CNTX.setOffset();\n        CNTX.mainContainer.innerHTML = \"\";\n        CNTX.araseMatrix();\n        CNTX.resetShuffledMatrix();\n        CNTX.setAllPartsInItsPos();\n        CNTX.showMatrix();\n\n        CNTX.shuffle();\n\n        CNTX.resetShuffledMatrix();\n        CNTX.setAllPartsInItsPos();\n        CNTX.shuffle();\n        clearInterval(CNTX.timerID);\n        CNTX.resetTimer();\n        CNTX.clearSteps();\n      }\n      if (e.target.id === 'imgSelect') {\n        CNTX.currentImage = e.target.options[e.target.selectedIndex].dataset.dim;\n        CNTX.setCSSProperty('.main-container div', `backgroundImage`, `url(\"../images/${CNTX.currentImage}.jpg\")`);\n        // CNTX.setClassRule('.main-container div', `background-image: url('../images/${CNTX.currentImage}.jpg');`);\n        CNTX.imagesDescribe.innerText = '';\n      }\n    }\n\n    document.onclick = controlIt;\n    document.onchange = controlSelect;\n    window.onresize = controllerMoblTabltDsckVer;\n  }\n}\n\nconst view = new View();\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  view.render();\n});\n\n// shuffleFn(elNum, shuffle) {\n//   if (shuffle <= elNum) {\n//     return;\n//   }\n//   if (this.getRepeated(elNum) === elNum) {\n//     return;\n//   }\n//   const ob = document.getElementById(`elID_${elNum}`);\n//   const obFake = document.getElementById(`elID_${shuffle}`);\n\n//   ob.className = `cube-bg${elNum}`;\n//   ob.classList.add(`cube-position${shuffle}`);\n\n//   obFake.className = `cube-bg${shuffle}`;\n//   obFake.classList.add(`cube-position${elNum}`);\n\n//   const mainElX = this.getPosX(shuffle);\n//   const mainElY = this.getPosY(shuffle);\n//   this.setPosX(shuffle, this.getPosX(elNum));\n//   this.setPosY(shuffle, this.getPosY(elNum));\n//   this.setPosX(elNum, mainElX);\n//   this.setPosY(elNum, mainElY);\n\n//   this.repeated.push(shuffle);\n// }\n\n// getRepeated(val) {\n//   return this.repeated.find((el) => el === val);\n// }\n\n// if (this.matrix[elNum - 1].x <= this.getXPXPosition(elNum)) { /* toright !isOnPropRow && !isOnPropCol */\n//   this.toRight(elNum);\n//   if (this.isElOnPropPos(elNum)) {\n//     this.tempLog += `эл на своей позиции${this.tempLogBR}`;\n//     return;\n//   }\n//   this.toTop(elNum);\n//   return;\n// }\n// console.log('toleft');\n// this.toLeft(elNum);\n// if (this.isElOnPropPos(elNum)) {\n//   this.tempLog += `эл на своей позиции${this.tempLogBR}`;\n//   return;\n// }\n// console.log('toTop');\n// this.toTop(elNum);\n// const isOnPropRow = this.isElOnPropPosY(elNum);\n// const isOnPropCol = this.isElOnPropPosX(elNum);\n// const isMElOnTheSameRow = this.matrix[this.mainElNum - 1].y === this.matrix[elNum - 1].y;\n// const isMElOnTheSameCol = this.matrix[this.mainElNum - 1].x === this.matrix[elNum - 1].x;\n// const isMElBefore = this.getCurrentElNumN(this.mainElNum) < this.getCurrentElNumN(elNum);\n// const isMElCanMoveToTheRight = (this.getCurrentElNumN(this.mainElNum) % this.matrixDimensionX) !== 0;\n// const isMElCanMoveToTheLeft = ((this.getCurrentElNumN(this.mainElNum) - 1) % this.matrixDimensionX) !== 0;\n// const isMElCanMoveToTheTop = this.matrix[this.mainElNum - 1].y !== 0;\n// const isMElCanMoveToTheBottom = this.matrix[this.mainElNum - 1].y < ((this.matrixDimensionY - 1) * this.getOffset());\n// const isDrggblToTop = this.isDrggblToTop(elNum);\n// const isDrggblToRight = this.isDrggblToRight(elNum);\n// const isDrggblToBottom = this.isDrggblToBottom(elNum);\n// const isDrggblToLeft = this.isDrggblToLeft(elNum);\n// const stepsToBottom = (this.getMountOfSteps(elNum, 'bottom') - 1);\n// const stepsTotop = (this.getMountOfSteps(elNum, 'top') - 1);\n// const stepsToRight = (this.getMountOfSteps(elNum, 'right') - 1);\n// const stepsToLeft = (this.getMountOfSteps(elNum, 'left') - 1);\n// if (isDrggblToLeft) {\n//   this.tempLog += `эл DrggblToLeft${this.tempLogBR}`;\n// }\n// if (isDrggblToTop) {\n//   this.tempLog += `эл DrggblToTop${this.tempLogBR}`;\n// }\n// if (isDrggblToRight) {\n//   this.tempLog += `эл DrggblToRight${this.tempLogBR}`;\n// }\n// if (isDrggblToBottom) {\n//   this.tempLog += `эл DrggblToBottom${this.tempLogBR}`;\n// }\n\n// /* гэл */\n// if (isMElBefore) {\n//   this.tempLog += `гэл раньше${this.tempLogBR}`;\n// } else {\n//   this.tempLog += `гэл позже${this.tempLogBR}`;\n// }\n\n// if (isMElOnTheSameRow) {\n//   this.tempLog += `гэл в одной строке с эл${this.tempLogBR}`;\n// }\n// if (isMElOnTheSameCol) {\n//   this.tempLog += `гэл в одной колонке с эл${this.tempLogBR}`;\n// }\n\n// if (isMElCanMoveToTheRight) {\n//   this.tempLog += `гэл ходит вправо${this.tempLogBR}`;\n// } else {\n//   this.tempLog += `гэл НЕ ходит вправо${this.tempLogBR}`;\n// }\n// if (isMElCanMoveToTheLeft) {\n//   this.tempLog += `гэл ходит влево${this.tempLogBR}`;\n// } else {\n//   this.tempLog += `гэл НЕ ходит влево${this.tempLogBR}`;\n// }\n// if (isMElCanMoveToTheTop) {\n//   this.tempLog += `гэл ходит вверх${this.tempLogBR}`;\n// } else {\n//   this.tempLog += `гэл НЕ ходит вверх${this.tempLogBR}`;\n// }\n// if (isMElCanMoveToTheBottom) {\n//   this.tempLog += `гэл ходит вниз${this.tempLogBR}`;\n// } else {\n//   this.tempLog += `гэл НЕ ходит вниз${this.tempLogBR}`;\n// }\n\n/* compute */\n// if (stepsToBottom >= 0) {\n//   this.tempLog += `(вниз) ${(this.getMountOfSteps(elNum, 'bottom') - 1)}${this.tempLogBR}`;\n// }\n// if (stepsTotop >= 0) {\n//   this.tempLog += `(вверх) ${(this.getMountOfSteps(elNum, 'top') - 1)}${this.tempLogBR}`;\n// }\n// if (stepsToRight >= 0) {\n//   this.tempLog += `(вправо) ${(this.getMountOfSteps(elNum, 'right') - 1)}${this.tempLogBR}`;\n// }\n// if (stepsToLeft >= 0) {\n//   this.tempLog += `(влево) ${(this.getMountOfSteps(elNum, 'left') - 1)}${this.tempLogBR}`;\n// }\n\n// this.tempLog += `гэл НЕ ходит вниз${this.tempLogBR}`;\n\n/* установить гэл перед эл влево и ход */\n\n/* если эл может драг влево\n    if (!isElOnItsLeftCol {\n      // console.log('el on its not Left Col');\n      if (this.isDrggblToLeft(elNum)) {\n        this.setShffldOnElNumAndGooo(elNum);\n      }\n    } */\n/* если эл может драг вверх\n    if (!this.isElOnItsTopRow(elNum)) {\n      // console.log('el not on its top row');\n      if (isDrggblToTop {\n        this.setShffldOnElNumAndGooo(elNum, this.matrixDimensionX * (-1));\n      }\n    } */\n\n//# sourceURL=webpack://gem-puzzle/./src/script.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./src/script.js");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;